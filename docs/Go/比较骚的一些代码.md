# æ¯”è¾ƒéªšçš„ä¸€äº›ä»£ç 

## æ“ä½œç³»ç»Ÿè¡¨æƒ…åŒ…

```go
func osEmoji(os string) string {
    switch os {
    case "linux":
        return "ğŸ§"
    case "macOS":
        return "ğŸ"
    case "windows":
        return "ğŸ–¥ï¸"
    case "iOS":
        return "ğŸ“±"
    case "android":
        return "ğŸ¤–"
    case "freebsd":
        return "ğŸ‘¿"
    case "openbsd":
        return "ğŸ¡"
    }
    return "ğŸ‘½"
}
```

## æ–‡ä»¶è‡ªåŠ¨é‡å‘½å

```go
for i := 1; gfile.Exists(dst); i++ {
    dst = gfile.Join(dir, fmt.Sprintf(fmt.Sprintf("%s(%d)%s", gfile.Name(in.File.Filename), i, gfile.Ext(in.File.Filename))))
}
```

## ç¼–è¯‘ç¯å¢ƒæ£€æŸ¥

```go
//go:build go1.21

package qtls

var _ int = "The version of quic-go you're using can't be built on Go 1.21 yet. For more details, please see https://github.com/quic-go/quic-go/wiki/quic-go-and-Go-versions."
```

## å‡½æ•°å®šä¹‰

```go
type st struct{}

func (s *st) name(string) {}

var (
    handles = []func(*st, string){
        (*st).name,
    }
)
```

## åµŒå¥—å–å€¼

```go
package main

import (
    "fmt"
)

type I1 interface {
    Name() string
}

type T1 struct{}

func (t *T1) Name() string {
    return "t1"
}

func (t *T1) Age() int {
    return 18
}

type T2 struct {
    I1
}

func (t *T2) Name() string {
    return t.I1.Name() + " t2"
}

func Fn(t I1) {
    fmt.Println(t.Name())
    fmt.Println(t.(*T2).I1.(*T1).Age())
}

func main() {
    t1 := &T1{}
    t2 := &T2{I1: t1}
    Fn(t2)
}
```

## å­—ç¬¦ä¸² <-> []byte

```go
package util

import (
    "unsafe"
)

// BytesToString converts byte slice to string.
func BytesToString(b []byte) string {
    return *(*string)(unsafe.Pointer(&b))
}

// StringToBytes converts string to byte slice.
func StringToBytes(s string) []byte {
    return *(*[]byte)(unsafe.Pointer(
        &struct {
            string
            Cap int
        }{s, len(s)},
    ))
}
```

## åˆ‡ç‰‡æˆªå–æ€§èƒ½ä¼˜åŒ–

```go
// æ€§èƒ½ä¼˜äº buf1 := buf[:length]
buf1 := buf[:uint32(length)]
```
