<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Beyla 工作原理 Beyla （当前分析 Beyla 版本为 v2.1.0）在工作时可以看作起了两个独立的子任务：应用程序可观测性和网络可观测。\n两个子任务之间没有强耦合关系，因此可分别进行详解。\n应用程序可观测性 应用程序可观测性整体执行流程如下图所示： 进程监控 在应用程序可观测性的进程监控组件中，初始阶段会加载 eBPF 程序，此程序用于监控系统调用 sys_bind，进而精准捕获绑定的端口信息。同时，会启动一个 goroutine 专门处理这些捕获到的信息，以确保处理的及时性和高效性。\n在该组件的主循环里，会按照预设的周期调用 listProcesses 函数，以此获取系统中所有进程的详细信息。随后，借助 snapshot 方法对新旧进程状态进行细致比较，能够精准捕获进程创建或进程删除事件。这些事件会通过通道被发送至下游组件，以便进行后续的处理。\n在处理 eBPF 捕获的信息时，若检测到端口为 Beyla 所关注的端口，那么在下一次获取系统进程信息时，会重新扫描进程的端口信息，并及时更新进程属性中的端口列表，从而保证端口信息的准确性和时效性。\nk8s 数据填充 该组件仅在启用 Kubernetes（k8s）信息发现功能时才会执行；若未启用此功能，组件将不会对任何事件进行处理。\n在对象初始化过程中，会创建一个 K8s 信息缓存区，专门用于存储 Pod、Service 等资源的元数据信息。初始化时，会首次加载 Pod、Service 等资源的元数据，同时启动一个 goroutine，按设定周期定期更新缓存内的信息，以此保证缓存数据与 K8s 集群状态的实时一致性。\n在该组件的主循环中，主要处理两类事件：\nPod 信息更新事件：一旦接收到此类事件，需及时更新缓存中的 Pod 信息，确保缓存数据始终反映最新的 Pod 状态。\n上游组件传递来的进程事件：\n进程创建事件：根据进程的 PID，在 K8s 集群中查找与之对应的 Pod 信息，将 Pod 的 Name、Namespace、ownerName 等关键信息添加到进程属性中，建立进程与 K8s 资源的关联。\n进程删除事件：从缓存中移除与该进程相关的所有信息，维护缓存数据的准确性与一致性。\n所有事件处理完毕后，组件会将事件转发至下一个组件，推动整个处理流程继续运行。\n进程匹配过滤 在组件的主循环中，会对上游组件传递过来的进程事件进行处理。具体处理逻辑如下：\n对于进程创建事件，会先在历史记录中进行检查。若该事件已被处理过，为避免重复处理，会直接将其丢弃。对于尚未处理过的事件，会进一步获取该进程的详细信息，其中包括父进程的 PID、进程执行路径等关键内容。接着，依据配置文件中设定的过滤规则，判断该进程是否属于需要过滤的范畴。若符合过滤条件，会直接丢弃该事件，从而确保进入后续处理流程的事件均为有效事件。\n对于进程删除事件，对于进程删除事件，会查看缓存中是否存在该进程的创建事件记录。若存在相应记录，则更新缓存中的对应信息，并将该记录从缓存中删除；若缓存中未记录该进程的创建事件，则直接丢弃该删除事件，以维持缓存数据的准确性和一致性。\n当所有事件完成过滤处理后，组件会将剩余的有效事件转发至下一个组件，以推动整个处理流程的持续进行。\n进程类型判断 在初始化阶段，系统会检查配置项 skip_go_specific_tracers。若该配置项未设置为跳过 Go 特定的追踪器，系统将加载预定义的 eBPF 模块，该模块用于追踪特定的 Go 函数，如 ServeHTTP、readRequest 等，详细信息可参考gotracer。\n"><title>Beyla 工作原理</title>
<link rel=canonical href=https://wlynxg.github.io/blog/p/beyla-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/><link rel=stylesheet href=/blog/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Beyla 工作原理"><meta property='og:description' content="Beyla 工作原理 Beyla （当前分析 Beyla 版本为 v2.1.0）在工作时可以看作起了两个独立的子任务：应用程序可观测性和网络可观测。\n两个子任务之间没有强耦合关系，因此可分别进行详解。\n应用程序可观测性 应用程序可观测性整体执行流程如下图所示： 进程监控 在应用程序可观测性的进程监控组件中，初始阶段会加载 eBPF 程序，此程序用于监控系统调用 sys_bind，进而精准捕获绑定的端口信息。同时，会启动一个 goroutine 专门处理这些捕获到的信息，以确保处理的及时性和高效性。\n在该组件的主循环里，会按照预设的周期调用 listProcesses 函数，以此获取系统中所有进程的详细信息。随后，借助 snapshot 方法对新旧进程状态进行细致比较，能够精准捕获进程创建或进程删除事件。这些事件会通过通道被发送至下游组件，以便进行后续的处理。\n在处理 eBPF 捕获的信息时，若检测到端口为 Beyla 所关注的端口，那么在下一次获取系统进程信息时，会重新扫描进程的端口信息，并及时更新进程属性中的端口列表，从而保证端口信息的准确性和时效性。\nk8s 数据填充 该组件仅在启用 Kubernetes（k8s）信息发现功能时才会执行；若未启用此功能，组件将不会对任何事件进行处理。\n在对象初始化过程中，会创建一个 K8s 信息缓存区，专门用于存储 Pod、Service 等资源的元数据信息。初始化时，会首次加载 Pod、Service 等资源的元数据，同时启动一个 goroutine，按设定周期定期更新缓存内的信息，以此保证缓存数据与 K8s 集群状态的实时一致性。\n在该组件的主循环中，主要处理两类事件：\nPod 信息更新事件：一旦接收到此类事件，需及时更新缓存中的 Pod 信息，确保缓存数据始终反映最新的 Pod 状态。\n上游组件传递来的进程事件：\n进程创建事件：根据进程的 PID，在 K8s 集群中查找与之对应的 Pod 信息，将 Pod 的 Name、Namespace、ownerName 等关键信息添加到进程属性中，建立进程与 K8s 资源的关联。\n进程删除事件：从缓存中移除与该进程相关的所有信息，维护缓存数据的准确性与一致性。\n所有事件处理完毕后，组件会将事件转发至下一个组件，推动整个处理流程继续运行。\n进程匹配过滤 在组件的主循环中，会对上游组件传递过来的进程事件进行处理。具体处理逻辑如下：\n对于进程创建事件，会先在历史记录中进行检查。若该事件已被处理过，为避免重复处理，会直接将其丢弃。对于尚未处理过的事件，会进一步获取该进程的详细信息，其中包括父进程的 PID、进程执行路径等关键内容。接着，依据配置文件中设定的过滤规则，判断该进程是否属于需要过滤的范畴。若符合过滤条件，会直接丢弃该事件，从而确保进入后续处理流程的事件均为有效事件。\n对于进程删除事件，对于进程删除事件，会查看缓存中是否存在该进程的创建事件记录。若存在相应记录，则更新缓存中的对应信息，并将该记录从缓存中删除；若缓存中未记录该进程的创建事件，则直接丢弃该删除事件，以维持缓存数据的准确性和一致性。\n当所有事件完成过滤处理后，组件会将剩余的有效事件转发至下一个组件，以推动整个处理流程的持续进行。\n进程类型判断 在初始化阶段，系统会检查配置项 skip_go_specific_tracers。若该配置项未设置为跳过 Go 特定的追踪器，系统将加载预定义的 eBPF 模块，该模块用于追踪特定的 Go 函数，如 ServeHTTP、readRequest 等，详细信息可参考gotracer。\n"><meta property='og:url' content='https://wlynxg.github.io/blog/p/beyla-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/'><meta property='og:site_name' content="Wlynxg's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:published_time' content='2025-08-22T17:34:52+08:00'><meta property='article:modified_time' content='2025-08-22T17:34:52+08:00'><meta name=twitter:title content="Beyla 工作原理"><meta name=twitter:description content="Beyla 工作原理 Beyla （当前分析 Beyla 版本为 v2.1.0）在工作时可以看作起了两个独立的子任务：应用程序可观测性和网络可观测。\n两个子任务之间没有强耦合关系，因此可分别进行详解。\n应用程序可观测性 应用程序可观测性整体执行流程如下图所示： 进程监控 在应用程序可观测性的进程监控组件中，初始阶段会加载 eBPF 程序，此程序用于监控系统调用 sys_bind，进而精准捕获绑定的端口信息。同时，会启动一个 goroutine 专门处理这些捕获到的信息，以确保处理的及时性和高效性。\n在该组件的主循环里，会按照预设的周期调用 listProcesses 函数，以此获取系统中所有进程的详细信息。随后，借助 snapshot 方法对新旧进程状态进行细致比较，能够精准捕获进程创建或进程删除事件。这些事件会通过通道被发送至下游组件，以便进行后续的处理。\n在处理 eBPF 捕获的信息时，若检测到端口为 Beyla 所关注的端口，那么在下一次获取系统进程信息时，会重新扫描进程的端口信息，并及时更新进程属性中的端口列表，从而保证端口信息的准确性和时效性。\nk8s 数据填充 该组件仅在启用 Kubernetes（k8s）信息发现功能时才会执行；若未启用此功能，组件将不会对任何事件进行处理。\n在对象初始化过程中，会创建一个 K8s 信息缓存区，专门用于存储 Pod、Service 等资源的元数据信息。初始化时，会首次加载 Pod、Service 等资源的元数据，同时启动一个 goroutine，按设定周期定期更新缓存内的信息，以此保证缓存数据与 K8s 集群状态的实时一致性。\n在该组件的主循环中，主要处理两类事件：\nPod 信息更新事件：一旦接收到此类事件，需及时更新缓存中的 Pod 信息，确保缓存数据始终反映最新的 Pod 状态。\n上游组件传递来的进程事件：\n进程创建事件：根据进程的 PID，在 K8s 集群中查找与之对应的 Pod 信息，将 Pod 的 Name、Namespace、ownerName 等关键信息添加到进程属性中，建立进程与 K8s 资源的关联。\n进程删除事件：从缓存中移除与该进程相关的所有信息，维护缓存数据的准确性与一致性。\n所有事件处理完毕后，组件会将事件转发至下一个组件，推动整个处理流程继续运行。\n进程匹配过滤 在组件的主循环中，会对上游组件传递过来的进程事件进行处理。具体处理逻辑如下：\n对于进程创建事件，会先在历史记录中进行检查。若该事件已被处理过，为避免重复处理，会直接将其丢弃。对于尚未处理过的事件，会进一步获取该进程的详细信息，其中包括父进程的 PID、进程执行路径等关键内容。接着，依据配置文件中设定的过滤规则，判断该进程是否属于需要过滤的范畴。若符合过滤条件，会直接丢弃该事件，从而确保进入后续处理流程的事件均为有效事件。\n对于进程删除事件，对于进程删除事件，会查看缓存中是否存在该进程的创建事件记录。若存在相应记录，则更新缓存中的对应信息，并将该记录从缓存中删除；若缓存中未记录该进程的创建事件，则直接丢弃该删除事件，以维持缓存数据的准确性和一致性。\n当所有事件完成过滤处理后，组件会将剩余的有效事件转发至下一个组件，以推动整个处理流程的持续进行。\n进程类型判断 在初始化阶段，系统会检查配置项 skip_go_specific_tracers。若该配置项未设置为跳过 Go 特定的追踪器，系统将加载预定义的 eBPF 模块，该模块用于追踪特定的 Go 函数，如 ServeHTTP、readRequest 等，详细信息可参考gotracer。\n"><link rel="shortcut icon" href=/blog/favicon.ico></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/blog/><img src=/blog/img/file_hu6889846174828548036.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🐂</span></figure><div class=site-meta><h1 class=site-name><a href=/blog>Wlynxg's Blog</a></h1><h2 class=site-description>The harder, ther luckier!</h2></div></header><ol class=menu-social><li><a href=https://github.com/wlynxg target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=mailto:liuauthor@foxmail.com target=_blank title=Mail rel=me><svg t="1730733819354" class="icon" viewBox="0 0 1024 1024" p-id="3570" width="24" height="24"><path d="M942.08 200.704s-1.024.0.0.0c-1.024-2.048-1.024-4.096-2.048-6.144-1.024-1.024-2.048-3.072-3.072-4.096l-1.024-1.024-1.024-1.024c-1.024-1.024-2.048-2.048-4.096-2.048h-1.024c-2.048-1.024-3.072-1.024-5.12-1.024h-1.024C788.48 163.84 649.216 153.6 512 153.6s-276.48 10.24-412.672 30.72h-1.024c-2.048.0-3.072 1.024-5.12 1.024H92.16c-1.024 1.024-3.072 1.024-4.096 2.048l-1.024 1.024-1.024 1.024c-1.024 1.024-2.048 2.048-3.072 4.096v1.024c-1.024 2.048-1.024 3.072-2.048 5.12C61.44 304.128 51.2 408.576 51.2 512s10.24 207.872 30.72 311.296c2.048 8.192 8.192 15.36 17.408 16.384C235.52 860.16 374.784 870.4 512 870.4s276.48-10.24 412.672-30.72c8.192-1.024 15.36-8.192 17.408-16.384C962.56 719.872 972.8 615.424 972.8 512s-10.24-207.872-30.72-311.296zm-60.416 19.456c-44.032 50.176-96.256 97.28-156.672 142.336C654.336 415.744 582.656 457.728 512 489.472c-77.824-36.864-148.48-78.848-212.992-126.976-56.32-41.984-108.544-90.112-156.672-142.336 122.88-17.408 246.784-25.6 369.664-25.6s246.784 8.192 369.664 25.6zm22.528 580.608C774.144 820.224 642.048 829.44 512 829.44s-262.144-9.216-392.192-28.672C101.376 705.536 92.16 608.256 92.16 512c0-87.04 8.192-175.104 22.528-262.144 48.128 53.248 102.4 102.4 159.744 145.408 69.632 52.224 144.384 96.256 229.376 135.168 3.072 1.024 6.144 2.048 8.192 2.048 3.072.0 5.12-1.024 8.192-2.048 76.8-32.768 153.6-78.848 229.376-135.168 60.416-46.08 114.688-94.208 159.744-144.384C924.672 337.92 931.84 424.96 931.84 512c0 96.256-9.216 193.536-27.648 288.768z" p-id="3571" fill="#707070"/></svg></a></li><li><a href=/blog/index.xml target=_blank title=RSS rel=me><svg t="1730718821658" class="icon" viewBox="0 0 1024 1024" p-id="21619" width="24" height="24"><path d="M554.666667 896C529.066667 896 512 878.933333 512 853.333333 512 665.6 358.4 512 170.666667 512 145.066667 512 128 494.933333 128 469.333333s17.066667-42.666667 42.666667-42.666666c234.666667.0 426.666667 192 426.666666 426.666666.0 25.6-17.066667 42.666667-42.666666 42.666667z" p-id="21620" fill="#707070"/><path d="M853.333333 896c-25.6.0-42.666667-17.066667-42.666666-42.666667.0-354.133333-285.866667-640-640-640-25.6.0-42.666667-17.066667-42.666667-42.666666S145.066667 128 170.666667 128C571.733334 128 896 452.266667 896 853.333333 896 878.933333 878.933333 896 853.333333 896z" p-id="21621" fill="#707070"/><path d="M213.333333 810.666667m-85.333333.0a85.333333 85.333333.0 10170.666667.0 85.333333 85.333333.0 10-170.666667.0z" p-id="21622" fill="#707070"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/blog/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/blog/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/blog/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/blog/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/blog/plan/><svg t="1730733517435" class="icon" viewBox="0 0 1024 1024" p-id="1581" width="24" height="24"><path d="M874.24 1013.76H143.36a94.72 94.72.0 01-94.72-94.72V188.16a94.72 94.72.0 0194.72-94.72h730.88a95.36 95.36.0 0194.72 94.72v730.88a94.72 94.72.0 01-94.72 94.72zM143.36 156.8a31.36 31.36.0 00-32 31.36v730.88a32 32 0 0032 32h730.88a32 32 0 0031.36-32V188.16a31.36 31.36.0 00-31.36-31.36z" fill="#707070" p-id="1582"/><path d="M926.08 399.36h-832a32 32 0 010-64h832a32 32 0 110 64zM339.84 273.28a31.36 31.36.0 01-31.36-32V39.04a31.36 31.36.0 0131.36-32 32 32 0 0132 32v202.24a32 32 0 01-32 32zm337.28.0a31.36 31.36.0 01-31.36-32V39.04a31.36 31.36.0 1164 0v202.24a31.36 31.36.0 01-32.64 32zM444.16 841.6a33.92 33.92.0 01-23.04-9.6l-128-138.24a32 32 0 1146.08-43.52L448 768l280.32-279.68a30.72 30.72.0 0144.8.0 31.36 31.36.0 010 44.16L466.56 832a32 32 0 01-22.4 9.6z" fill="#707070" p-id="1583"/></svg>
<span>Plan</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#进程监控>进程监控</a></li><li><a href=#k8s-数据填充>k8s 数据填充</a></li><li><a href=#进程匹配过滤>进程匹配过滤</a></li><li><a href=#进程类型判断>进程类型判断</a></li><li><a href=#容器信息更新>容器信息更新</a></li><li><a href=#tracer-构建>Tracer 构建</a></li><li><a href=#数据导出>数据导出</a></li></ol><ol><li><a href=#maptracer>MapTracer</a></li><li><a href=#ringbuftracer>RingBufTracer</a></li><li><a href=#协议过滤>协议过滤</a></li><li><a href=#flow-去重>Flow 去重</a></li><li><a href=#interface-查询>Interface 查询</a></li><li><a href=#cidr-解析>CIDR 解析</a></li><li><a href=#k8s-数据填充-1>k8s 数据填充</a></li><li><a href=#dns-反向解析>DNS 反向解析</a></li><li><a href=#属性过滤>属性过滤</a></li><li><a href=#数据导出-1>数据导出</a></li></ol><ol><li><a href=#网络级别写入><strong>网络级别写入</strong></a></li><li><a href=#go-库级别写入><strong>Go 库级别写入</strong></a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/blog/categories/%E4%BA%91%E5%8E%9F%E7%94%9F/ style=background-color:#326ce5;color:#fff>云原生</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/blog/p/beyla-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/>Beyla 工作原理</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Aug 22, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 5 分钟</time></div></footer></div></header><section class=article-content><h1 id=beyla-工作原理>Beyla 工作原理</h1><p>Beyla （当前分析 Beyla 版本为 v2.1.0）在工作时可以看作起了两个独立的子任务：<strong>应用程序可观测性</strong>和<strong>网络可观测。</strong></p><p>两个子任务之间没有强耦合关系，因此可分别进行详解。</p><h1 id=应用程序可观测性>应用程序可观测性</h1><p>应用程序可观测性整体执行流程如下图所示：
<img src=https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-113800.png loading=lazy alt=image.png></p><h2 id=进程监控>进程监控</h2><p>在应用程序可观测性的进程监控组件中，初始阶段会加载 eBPF 程序，此程序用于监控系统调用 <code>sys_bind</code>，进而精准捕获绑定的端口信息。同时，会启动一个 goroutine 专门处理这些捕获到的信息，以确保处理的及时性和高效性。</p><p> 在该组件的主循环里，会按照预设的周期调用 <code>listProcesses</code> 函数，以此获取系统中所有进程的详细信息。随后，借助 <code>snapshot</code> 方法对新旧进程状态进行细致比较，能够精准捕获进程创建或进程删除事件。这些事件会通过通道被发送至下游组件，以便进行后续的处理。</p><p> 在处理 eBPF 捕获的信息时，若检测到端口为 Beyla 所关注的端口，那么在下一次获取系统进程信息时，会重新扫描进程的端口信息，并及时更新进程属性中的端口列表，从而保证端口信息的准确性和时效性。</p><h2 id=k8s-数据填充>k8s 数据填充</h2><p>该组件仅在启用 Kubernetes（k8s）信息发现功能时才会执行；若未启用此功能，组件将不会对任何事件进行处理。</p><p>在对象初始化过程中，会创建一个 K8s 信息缓存区，专门用于存储 Pod、Service 等资源的元数据信息。初始化时，会首次加载 Pod、Service 等资源的元数据，同时启动一个 goroutine，按设定周期定期更新缓存内的信息，以此保证缓存数据与 K8s 集群状态的实时一致性。</p><p>   在该组件的主循环中，主要处理两类事件：</p><ol><li><p>Pod 信息更新事件：一旦接收到此类事件，需及时更新缓存中的 Pod 信息，确保缓存数据始终反映最新的 Pod 状态。</p></li><li><p>上游组件传递来的进程事件：</p><ol start=3><li><p>进程创建事件：根据进程的 PID，在 K8s 集群中查找与之对应的 Pod 信息，将 Pod 的 Name、Namespace、ownerName 等关键信息添加到进程属性中，建立进程与 K8s 资源的关联。</p></li><li><p>进程删除事件：从缓存中移除与该进程相关的所有信息，维护缓存数据的准确性与一致性。</p></li></ol></li></ol><p>    所有事件处理完毕后，组件会将事件转发至下一个组件，推动整个处理流程继续运行。</p><h2 id=进程匹配过滤>进程匹配过滤</h2><p>在组件的主循环中，会对上游组件传递过来的进程事件进行处理。具体处理逻辑如下：</p><p>对于<code>进程创建</code>事件，会先在历史记录中进行检查。若该事件已被处理过，为避免重复处理，会直接将其丢弃。对于尚未处理过的事件，会进一步获取该进程的详细信息，其中包括父进程的 PID、进程执行路径等关键内容。接着，依据配置文件中设定的过滤规则，判断该进程是否属于需要过滤的范畴。若符合过滤条件，会直接丢弃该事件，从而确保进入后续处理流程的事件均为有效事件。</p><p>对于<code>进程删除</code>事件，对于进程删除事件，会查看缓存中是否存在该进程的创建事件记录。若存在相应记录，则更新缓存中的对应信息，并将该记录从缓存中删除；若缓存中未记录该进程的创建事件，则直接丢弃该删除事件，以维持缓存数据的准确性和一致性。</p><p>当所有事件完成过滤处理后，组件会将剩余的有效事件转发至下一个组件，以推动整个处理流程的持续进行。</p><h2 id=进程类型判断>进程类型判断</h2><p>在初始化阶段，系统会检查配置项 <code>skip_go_specific_tracers</code>。若该配置项未设置为跳过 Go 特定的追踪器，系统将加载预定义的 eBPF 模块，该模块用于追踪特定的 Go 函数，如 <code>ServeHTTP</code>、<code>readRequest</code> 等，详细信息可参考<a class=link href=https://github.com/grafana/beyla/tree/main/bpf/gotracer target=_blank rel=noopener>gotracer</a>。</p><p>对于<code>进程创建</code>事件，系统会深入分析进程可执行文件的类型，通过解析 ELF 文件头、符号表等信息，精准识别文件特征。同时，针对所有进程，系统会查询其执行程序的 ELF 信息，并确定执行进程所使用的语言类型，涵盖 Go、C/C++、Rust、Python、Ruby、Java（含 GraalVM Native）、NodeJS、.NET 等多种常见语言。</p><p>对于 Go 进程，系统会判断其是否为非 GoProxy 进程。不过，当前的<a class=link href=https://github.com/grafana/beyla/blob/a2c0758871fc1a4823868516cb17737756b38690/pkg/internal/discover/typer.go#L187 target=_blank rel=noopener>判断函数</a>存在一定局限性，若一个 Go 程序仅使用标准库且未定义自定义函数，该进程可能会被误判为 GoProxy。对于确认为非 GoProxy 的 Go 进程，系统将利用 eBPF 技术追踪特定函数，以实现对其运行状态的精准监控；而对于其他语言的进程，系统会额外采集子进程的 PID，为后续的分析和处理提供更全面的数据。</p><p>对于<code>进程删除</code>事件，系统会检查缓存中是否存在该进程的创建事件记录。若存在，系统会更新缓存中的对应信息，并将该记录从缓存中移除，以确保缓存数据的准确性和一致性。</p><p>在完成对所有事件的过滤和处理后，系统会将处理后的事件转发至下一个组件，以推动整个可观测性流程的持续进行。</p><h2 id=容器信息更新>容器信息更新</h2><p>该组件仅在启用 Kubernetes（K8s）信息发现功能时才会投入运行。若未启用此功能，该组件将不会对任何事件执行处理操作。</p><p>对于<code>进程创建</code>事件，组件会建立进程与相应容器的映射关系，添加二者间的关联信息，为后续基于容器环境的进程分析提供基础。</p><p>对于<code>进程删除</code>事件，组件不会进行任何处理，直接跳过该事件。</p><p>在完成对所有事件的过滤和处理后，系统会将处理后的事件转发至下一个组件，以推动整个可观测性流程的持续进行。</p><h2 id=tracer-构建>Tracer 构建</h2><p>在处理进程创建事件时，系统会依据 OpenTelemetry SDK 注入的配置状态进行操作。目前，OpenTelemetry SDK 注入功能仅支持 Java 程序。若该功能处于开启状态，系统将对 Java 进程执行 OpenTelemetry SDK 注入操作，以此增强其可观测性。若未开启 OpenTelemetry SDK 注入功能，则需获取对应进程的 Tracer。</p><p>在获取 Tracer 过程中，系统首先会检查该进程是否已存在 Tracer。若已存在，系统将更新相关信息后返回该 Tracer。若不存在，则需创建新的 Tracer，具体创建逻辑如下：</p><ul><li><p>对于 Go 程序：当满足特定条件（如配置中跳过特定的 Go 跟踪器、执行系统级检测时发现存在检测错误或偏移量为空等情况），系统将记录警告信息，并尝试重用可重用的跟踪器。若不满足上述条件，则使用通用跟踪器。</p></li><li><p>对于支持的其他语言（Node.js、Java、Ruby、Python、.NET、Rust、PHP）程序，系统会优先尝试重用可重用的跟踪器。若无法重用，则使用通用跟踪器。</p></li><li><p>对于其他不支持的语言，系统将直接忽略该进程，并记录相关信息，以便后续排查与分析。</p></li></ul><p>    对于<code>进程删除</code>事件，系统仅需更新缓存中与该进程相关的信息，以此确保缓存数据与实际进程状态保持一致。</p><p>    当前 Byela 实现的 Tracer 有以下几种：</p><ul><li><p><code>generictracer</code>：通用追踪器，主要用于追踪非 Go 应用的 HTTP 和 gRPC 调用，通过系统调用跟踪实现，包括<code>read/write/connect</code>等系统调用的监控；</p></li><li><p><code>gotracer</code>：专门用于Go应用的追踪器，通过<code>uprobes</code>机制跟踪 Go 运行时函数，包括HTTP处理、gRPC调用、SQL操作、Kafka操作、Redis操作等；</p></li><li><p><code>gpuevent</code>：GPU事件追踪器，监控CUDA相关系统调用，收集GPU内核启动和内存分配等信息；</p></li><li><p><code>httptracer</code>：HTTP协议追踪器，专注于HTTP层面的追踪，包括请求方法、URL、状态码等信息的采集；</p></li><li><p><code>tctracer</code>：网络流量追踪器，基于TC（Traffic Control）实现，用于收集网络包信息，包括源目标IP、端口、协议类型等。</p></li></ul><h2 id=数据导出>数据导出</h2><p>当完成上一阶段 Tracer 的构建后，一旦有相关事件触发，Tracer 便会启动，开始处理由 eBPF 采集的数据。在运行过程中，Tracer 会将采集到的 eBPF 数据转换为符合特定格式的 <code>request.Span</code> 数据。</p><p>转换完成的 <code>request.Span</code> 数据，对<code>request.Spa</code>数据进行填充（如k8s相关信息）和过滤,将通过多种渠道进行输出，包括但不限于 OTLP 端点、Prometheus Metrics 服务、Grafana Alloy 以及日志输出。这些输出方式能够满足不同场景下对数据的使用需求，为系统的监控、分析以及运维提供多维度的数据支持 。</p><h1 id=网络可观测性>网络可观测性</h1><p>网络可观测性执行流程如下所示：
<img src=https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-115343.png loading=lazy alt=image.png></p><h2 id=maptracer>MapTracer</h2><p>MapTracer 的核心功能是对 flow 数据进行聚合，其主要采集并导出的关键数据指标涵盖：数据包数量、字节数、流起始时间、流结束时间以及连接标志等。</p><p>在初始化阶段，Beyla 会依据配置创建内核网络事件接收器 <code>Fetcher</code>。<code>Fetcher</code> 的实现方式有 <code>tc</code> 和 <code>socket_filter</code> 两种，默认采用 <code>socket_filter</code>。作为运行于内核态的 eBPF 程序，<code>Fetcher</code> 会持续不断地采集 flow 相关信息。尤为重要的是，当 flow 首次出现时，<code>Fetcher</code>会拷贝 packet 数据，以便后续进行更全面的分析。</p><p>在主循环过程中，MapTracer 会按照设定的周期调用已创建的 <code>Fetcher</code>。<code>Fetcher</code> 将内核中 eBPF Map 所获取的网络流信息传递给 MapTracer。MapTracer 在接收到这些信息后，会对数据执行合并处理操作，随后将处理后的结果传递给下一个组件，确保数据在整个系统中得以有序流转和进一步处理 。</p><h2 id=ringbuftracer>RingBufTracer</h2><p>RingBufTracer 的工作机制聚焦于网络流初始出现阶段的信息采集。当某个 flow 首次现身时，运行在内核态的 eBPF 程序会将对应的 packet 数据拷贝至由 Go 实现的用户态程序中。随后，Go 程序对该 packet 展开解析，从中提取出网络流的关键信息，包括源地址、源端口、目的地址、目的端口、捕获时间以及网络协议等。</p><p>在初始化环节，Beyla 会复用此前 MapTracer 创建的 <code>Fetcher</code>。<code>Fetcher</code>作为内核网络事件接收器，持续为 RingBufTracer 提供稳定的数据来源。</p><p>进入主循环后，RingBufTracer 会以阻塞的方式，不断从 <code>ringBuffer</code> 中读取 eBPF 程序捕获的 packet 信息。一旦成功读取到 packet，便立即对其进行解析，提取出 flow 的相关详细信息，并将这些信息传递给下一个组件，保障数据处理流程的连贯性。</p><p>总体来看，RingBufTracer 与 MapTracer 在功能上相互补充。RingBufTracer 主要负责在 flow 初始化的关键节点采集详细信息，为后续的分析提供初始数据；而 MapTracer 则侧重于按照一定周期，定期更新 flow 的相关信息，确保对网络流的持续跟踪与监控，两者协同工作，共同完善了对网络流数据的全面采集与处理体系。</p><h2 id=协议过滤>协议过滤</h2><p>只有在配置了协议过滤相关参数（即<code>BEYLA_NETWORK_PROTOCOLS</code>和<code>BEYLA_NETWORK_EXCLUDE_PROTOCOLS</code>）时，该组件才会启动运行。</p><p>运行过程中，组件会依据协议过滤配置，对上层传递而来的事件进行筛选。将符合过滤条件的事件提取出来，然后把这些经过滤后的事件传递至下一个组件，以此确保整个处理流程中事件数据的精准性与有效性。</p><h2 id=flow-去重>Flow 去重</h2><p>该组件的核心功能是依据特定配置（包括 <code>BEYLA_NETWORK_DEDUPER_FC_TTL</code>、<code>BEYLA_NETWORK_DEDUPER</code> 和 <code>CacheActiveTimeout</code>）对重复的网络流（flow）进行处理。在接收到网络流数据后，组件会对其进行检查，识别出其中重复的 flow 并将其过滤掉，以避免对相同的网络流进行重复处理。经过过滤后，仅保留唯一的、有价值的 flow 数据，并将这些数据传递给下一个组件，从而提高整个系统的数据处理效率和准确性。</p><h2 id=interface-查询>Interface 查询</h2><p>当<code>BEYLA_NETWORK_DEDUPER</code>配置为<code>first_come</code>时，该组件处于非工作状态。</p><p>而当该组件启动工作时，它会依据 flow 的 Interface Id 进行解析，从而获取对应的 Interface Name，并将其填充至 flow 信息当中。与此同时，组件还会为 flow 填充 SrcName、DstName、BeylaIP 等属性。待所有相关属性填充完成，确保 flow 信息完整无误后，组件会将该 flow 传递给下一个组件，推动数据处理流程的持续进行 。</p><h2 id=cidr-解析>CIDR 解析</h2><p>仅当 <code>BEYLA_NETWORK_CIDRS</code> 被设置时，该组件才会开始运作。</p><p>组件启动后，会依据配置的 <code>BEYLA_NETWORK_CIDRS</code> 对 flow 中的源 IP（src IP）和目的 IP（dst IP）进行解析，将它们匹配到与之对应的最窄 CIDR 范围内。随后，把匹配得到的 CIDR 值分别填充到 flow 的元数据（Metadata）中的 <code>src.cidr</code> 和 <code>dst.cidr</code> 字段。待完成这些属性的填充，确保 flow 元数据信息完整后，将该 flow 传递给下一个组件，以推进后续的数据处理流程。</p><h2 id=k8s-数据填充-1>k8s 数据填充</h2><p>只有在启用 Kubernetes（k8s）数据获取功能时，该组件才会投入运行。</p><p>组件运行期间，会针对 flow 的源 IP（src IP）和目的 IP（dst IP），与缓存中的 k8s 信息进行匹配操作。通过这种匹配，能够精准地为 flow 填充与 k8s 相关的属性。在此过程中，该组件会复用应用程序可观测性体系中已有的 k8s 信息获取组件，以确保获取到的 k8s 信息准确且及时。</p><p>待完成所有 k8s 相关信息的填充，使 flow 的相关属性完整后，组件会将该 flow 传递至下一个组件，从而推动整个数据处理流程的持续进行。</p><h2 id=dns-反向解析>DNS 反向解析</h2><p>仅当启用 DNS 反向解析功能，即<code>BEYLA_NETWORK_REVERSE_DNS_TYPE</code> 配置为<code>local</code>或<code>ebpf</code>时，该组件才会开始工作。需要注意的是，此功能目前属于实验性功能，默认处于关闭状态。</p><p>DNS 反向解析流程会依据所设置的类型来开展工作：</p><ul><li><p><code>local</code>类型：系统会调用 <code>net.LookupAddr</code> 函数，实现从反向 IP 到域名的解析。</p></li><li><p><code>ebpf</code>类型：组件会注册一个 eBPF 程序，该程序能够捕获并分析内核中 XDP（Express 数据路径）级别的 DNS 响应数据包，随后将这些数据包传递至用户态程序进行解析。用户态程序会把解析结果缓存在内存中，当有查询需求时，直接返回缓存中的查询结果。</p></li></ul><p>    一旦反向解析成功，系统会将 <code>SrcName</code> 和 <code>DstName</code> 替换为解析得到的主机名。在完成所有信息的填充后，该组件会将处理后的 flow 传递给下一个组件，以推动整个流程继续运行。</p><h2 id=属性过滤>属性过滤</h2><p>仅在配置了 network 过滤的情况下，该组件才会启动运行。</p><p>组件运行时，会依据所配置的过滤属性，对上一级传递而来的 flow 数据进行筛选。将符合过滤要求的 flow 数据提取出来，随后把这些经过滤的 flow 数据传递给下一个组件，以此保证数据处理流程中数据的精准性和有效性。</p><h2 id=数据导出-1>数据导出</h2><p>在此环节，系统会依据预先配置的数据导出组件，为数据提供多样化的导出途径。支持通过 OTLP 端点、Prometheus Metrics 服务、Grafana Alloy 以及日志输出等多种方式，将处理后的数据输出，以满足不同场景下对数据使用和分析的需求。</p><h1 id=分布式追踪>分布式追踪</h1><p>在 Beyla 的功能列表中，有一个较为重要的功能：<strong><a class=link href=https://grafana.com/docs/beyla/latest/distributed-traces/ target=_blank rel=noopener>分布式追踪</a>****。</strong></p><p>Beyla 读取任何传入的追踪上下文标头值，跟踪程序执行流程，并通过在传出的 HTTP/gRPC 请求中自动添加 <code>traceparent</code> 字段来传播追踪上下文。如果应用程序已在传出的请求中添加了 <code>traceparent</code> 字段，Beyla 将使用该值进行追踪，而不是使用其自身生成的追踪上下文。如果 Beyla 找不到传入的 <code>traceparent</code> 上下文值，它将根据 W3C 规范生成一个。</p><p>Beyla 追踪上下文传播通过两种不同的方式实现：<strong>在网络级别写入传出的标头信息</strong>和**在库级别为 Go 写入标头信息。**Beyla 会根据服务所用的编程语言，自动使用一种或两种上下文传播方法。</p><h2 id=网络级别写入><strong>网络级别写入</strong></h2><p>网络级别写入<code>traceparent id</code>主要依赖于 <code>tc</code>实现。Beyla 会注册一个在<code>tcp_recvmsg</code>和<code>tcp_sendmsg</code>函数上的 eBPF hook，用以监测系统内的 HTTP/s 流量。</p><p>当监测到 HTTP 请求接收或发送时，Beyla 会查询或生成一个<code>traceparent id</code>。具体流程如下：</p><ol><li><p>根据连接信息（ <code>src.ip</code>、<code>src.port</code>、<code>dts.ip</code>、<code>dst.port</code>）查询，如果有则返回。</p></li><li><p>预先生成一个<code>traceparent id</code>；</p></li><li><p>对于客户端，先使用发起系统调用的线程 PID 进行查询，如果查询不到再使用 父线程 PID、祖父线程 PID 进行查询。对于服务端，则使用连接对象相关信息进行查询；</p></li><li><p>在 HTTP 请求头中搜索<code>traceparent:</code> 字串来查询<code>traceparent id</code>，如果能够搜索到则使用该<code>traceparent id</code>替换原有的<code>traceparent id</code>并返回；</p></li></ol><p>    当得到<code>traceparent id</code>后，Beyla 仅会将相关信息与<code>traceparent id</code>的映射关系写入内存中。</p><p>    同时 Beyla 还对<code>sk_msg</code>（发生在<code>sendmsg</code>过程中）进行 Hook。当触发该 Hook 时，Beyla 会根据连接信息在内存中查询<code>traceparent id</code>，将查询到的<code>traceparent id</code>写入到实际的 packet 中，如下图所示（Python实现的服务，在接收HTTP请求后会根据路由再请求下一个HTTP服务）：</p><p><img src=https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-115144.png loading=lazy></p><p>由于 Beyla 查询<code>traceparent id</code>的逻辑限制，会导致某些情况下不能正确识别到<code>traceparent id</code>。以下举两个例子：</p><ul><li><p>服务在一开始启用了两个线程，一个线程作为 HTTP Server处理 HTTP 请求，另外一个线程作为 HTTP Client 向其他服务发起 HTTP 请求，两个线程之间通过队列进行通信。此时由于接收 HTTP 请求的线程和发起 HTTP 请求的线程是兄弟关系而非父子关系，此时无法正确追踪<code>traceparent id</code>。</p></li><li><p>HTTP Server 处理路由并向其他服务发起 HTTP 请求时，需要创建新线程发起请求。如果发起 HTTP 请求的线程和接收 HTTP 请求的线程之间辈数超过 3，此时也无法正确追踪 <code>traceparent id</code>。</p></li></ul><p>以上两种情况都会出现如下情形：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Plain data-lang=Plain><span class=line><span class=cl>2025-04-10 17:45:30.41054530 (1.047037ms[1.047037ms]) HTTPClient 200 GET /go/pkg/ [127.0.0.1 as 127.0.0.1:58412]-&gt;[127.0.0.1 as 127.0.0.1:8080] size:256B svc=[python3.11 python] traceparent=[00-778998dfcacdc40d42d1608e3ee521b6-5b0c6dd06909f1f9[0000000000000000]-01]
</span></span><span class=line><span class=cl>2025-04-10 17:45:30.41054530 (748.383µs[748.383µs]) HTTP 200 GET /go/pkg/ [127.0.0.1 as 127.0.0.1:58412]-&gt;[127.0.0.1 as 127.0.0.1:8080] size:222B svc=[python3.11 python] traceparent=[00-778998dfcacdc40d42d1608e3ee521b6-86d528370b3c6672[5b0c6dd06909f1f9]-01]
</span></span><span class=line><span class=cl>2025-04-10 17:45:30.41054530 (10.189389ms[10.189389ms]) HTTP 200 GET /go/pkg/ [192.168.5.17 as 192.168.5.17:51809]-&gt;[192.168.5.14 as 192.168.5.14:8082] size:484B svc=[python3.11 python] traceparent=[00-ea329470babdc498a69bf41e258bbf3a-12ee24f1a90a3423[0000000000000000]-01]
</span></span></code></pre></td></tr></table></div></div><p>正常情况下输出如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Plain data-lang=Plain><span class=line><span class=cl>2025-04-10 17:42:37.41054237 (1.164387ms[1.164387ms]) HTTPClient 200 GET /go/pkg/ [127.0.0.1 as 127.0.0.1:34758]-&gt;[127.0.0.1 as 127.0.0.1:8080] size:256B svc=[python3.11 python] traceparent=[00-6b6ea0ea5f0393b4faafb18f70c8bc2a-4fbf18d92e993d74[52a8d0be548b0550]-01]
</span></span><span class=line><span class=cl>2025-04-10 17:42:37.41054237 (811.599µs[811.599µs]) HTTP 200 GET /go/pkg/ [127.0.0.1 as 127.0.0.1:34758]-&gt;[127.0.0.1 as 127.0.0.1:8080] size:228B svc=[python3.11 python] traceparent=[00-6b6ea0ea5f0393b4faafb18f70c8bc2a-e9aa78a1fb15332e[4fbf18d92e993d74]-01]
</span></span><span class=line><span class=cl>2025-04-10 17:42:37.41054237 (8.821989ms[8.821989ms]) HTTP 200 GET /go/pkg/ [192.168.5.17 as 192.168.5.17:51648]-&gt;[192.168.5.14 as 192.168.5.14:8082] size:494B svc=[python3.11 python] traceparent=[00-6b6ea0ea5f0393b4faafb18f70c8bc2a-52a8d0be548b0550[0000000000000000]-01]
</span></span></code></pre></td></tr></table></div></div><p>对于 HTTPs 流量，由于 eBPF 无法直接在 HTTP Header 中写入<code>traceparent id</code>，Beyla 只好在 TCP packet 中写入<code>traceparent id</code>用以追踪上下文。L7 代理和负载均衡器会破坏 TCP/IP 上下文传播，因为原始数据包被丢弃并在下游重放。</p><h2 id=go-库级别写入><strong>Go 库级别写入</strong></h2><p>在 Go 语言中，由于线程和进程在语言层面被屏蔽掉，Go 使用了 goroutine 的方式来取代线程和进程，Go 语言会根据情况自动创建新线程来执行函数。因此网络层面实现中使用 PID 的关系来追踪<code>traceparent id</code>的方式在Go语言（Rust 的 tokio 也会有该问题）中无法使用。Go 语言需要使用特殊的方式来实现<code>traceparent id</code>的自动追踪。</p><p>Beyla 使用通过对 Go 库函数进行 Hook 的方式实现 Go 服务的<code>traceparent id</code>自动追踪。</p><p>对于 HTTP 服务，Beyla 通过 eBPF 对 <code>ServeHTTP</code>函数进行 Hook。当<code>ServeHTTP</code>接收到请求时，Beyla 会针对该请求查询或生成一个<code>traceparent id</code>。具体流程如下：</p><ol><li><p>利用获取请求的 goroutine addr 作为 key 值，在缓存中查询<code>traceparent id</code>。若有则直接返回；</p></li><li><p>根据连接信息（ <code>src.ip</code>、<code>src.port</code>、<code>dts.ip</code>、<code>dst.port</code>）查询。若有则直接返回；</p></li><li><p>以上都没有则生成一个新的<code>traceparent id</code>并返回。</p></li></ol><p>    对于 HTTP Client，Beyla 通过 eBPF 对 <code>roundTrip</code>函数进行 Hook。当<code>roundTrip</code>需要写入 HTTP 请求时，Beyla 同样会该请求查询或生成一个<code>traceparent id</code>，然后将 Go 进程 PID 作为 Key 值写入到内存中。具体流程如下：</p><ol start=4><li><p>利用发起函数调用的 goroutine addr 作为 key 值，在缓存中查询<code>traceparent id</code>。如果查询不到再使用 父goroutine addr、祖父 goroutine addr 进行查询。若有则直接返回；</p></li><li><p>以上都没有则生成一个新的<code>traceparent id</code>并返回。</p></li></ol><p>    当 packet 在执行<code>sendmsg</code>进行发送时，同样会触发到网络级别写入写入中介绍的<code>sk_msg</code>钩子。在此时完成<code>traceparent id</code>的写入。执行结果如下图所示（Go实现的服务，在接收HTTP请求后会根据路由再请求下一个HTTP服务）：</p><p><img src=https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-120043.png loading=lazy alt=image.png></p><p>如网络级别写入一样，Go服务同样会有一些无法发送<code>traceparent id</code>自动追踪的场景。以下举两个例子：</p><ul><li><p>服务在一开始启用了两个 goroutine，一个作为 HTTP Server处理 HTTP 请求，另外一个作为 HTTP Client 向其他服务发起 HTTP 请求，两个线程之间通过 channel 进行通信。此时由于接收 HTTP 请求的 goroutine 和发起 HTTP 请求的 groutine 是兄弟关系而非父子关系，此时无法正确追踪<code>traceparent id</code>。</p></li><li><p>HTTP Server 处理路由并向其他服务发起 HTTP 请求时，需要创建新 goroutine 发起请求。如果发起 HTTP 请求的 goroutine 和接收 HTTP 请求的 goroutine 之间辈数超过 3，此时也无法正确追踪 <code>traceparent id</code>。</p></li></ul><p>以上两种情况都会出现如下情形：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>2025-04-10 18:30:00.4106300 <span class=o>(</span>758.196µs<span class=o>[</span>758.196µs<span class=o>])</span> HTTP <span class=m>200</span> GET /go/ <span class=o>[</span>127.0.0.1 as 127.0.0.1:43180<span class=o>]</span>-&gt;<span class=o>[</span>127.0.0.1 as 127.0.0.1:8080<span class=o>]</span> size:176B <span class=nv>svc</span><span class=o>=[</span>python3.11 python<span class=o>]</span> <span class=nv>traceparent</span><span class=o>=[</span>00-817f47cdef64fbe0118cac6523ebe002-3f45883ebf8be9dd<span class=o>[</span>5e75cc3cbd3ecd69<span class=o>]</span>-01<span class=o>]</span>
</span></span><span class=line><span class=cl>2025-04-10 18:30:00.4106300 <span class=o>(</span>2.829546ms<span class=o>[</span>2.829546ms<span class=o>])</span> HTTPClient <span class=m>200</span> GET /go/ <span class=o>[</span>127.0.0.1 as 127.0.0.1:43180<span class=o>]</span>-&gt;<span class=o>[</span>127.0.0.1 as 127.0.0.1:8080<span class=o>]</span> size:0B <span class=nv>svc</span><span class=o>=[</span>main go<span class=o>]</span> <span class=nv>traceparent</span><span class=o>=[</span>00-817f47cdef64fbe0118cac6523ebe002-5e75cc3cbd3ecd69<span class=o>[</span>0000000000000000<span class=o>]</span>-01<span class=o>]</span>
</span></span><span class=line><span class=cl>2025-04-10 18:30:00.4106300 <span class=o>(</span>3.279114ms<span class=o>[</span>3.193699ms<span class=o>])</span> HTTP <span class=m>200</span> GET /go/ <span class=o>[</span>192.168.5.17 as 192.168.5.17:54565<span class=o>]</span>-&gt;<span class=o>[</span>192.168.5.14 as 192.168.5.14:8081<span class=o>]</span> size:0B <span class=nv>svc</span><span class=o>=[</span>main go<span class=o>]</span> <span class=nv>traceparent</span><span class=o>=[</span>00-8d790f6b6821b01c3acfce8492cc2734-f5288931e082d9f2<span class=o>[</span>0000000000000000<span class=o>]</span>-01<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>正常情况应如下所示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Plain data-lang=Plain><span class=line><span class=cl>2025-04-10 18:26:50.41062650 (2.077553ms[2.077553ms]) HTTPClient 200 GET /go/ [127.0.0.1 as 127.0.0.1:38622]-&gt;[127.0.0.1 as 127.0.0.1:8080] size:0B svc=[main go] traceparent=[00-21a5d4c0e3c2b4bd842cbb315c2d1883-268a2bf2daa5c329[1c742eccd32743af]-01]
</span></span><span class=line><span class=cl>2025-04-10 18:26:50.41062650 (723.341µs[723.341µs]) HTTP 200 GET /go/ [127.0.0.1 as 127.0.0.1:38622]-&gt;[127.0.0.1 as 127.0.0.1:8080] size:176B svc=[python3.11 python] traceparent=[00-21a5d4c0e3c2b4bd842cbb315c2d1883-7a07f0cb32074e96[268a2bf2daa5c329]-01]
</span></span><span class=line><span class=cl>2025-04-10 18:26:50.41062650 (2.915154ms[2.837631ms]) HTTP 200 GET /go/ [192.168.5.17 as 192.168.5.17:54338]-&gt;[192.168.5.14 as 192.168.5.14:8081] size:0B svc=[main go] traceparent=[00-21a5d4c0e3c2b4bd842cbb315c2d1883-1c742eccd32743af[0000000000000000]-01]
</span></span></code></pre></td></tr></table></div></div><p>对于其他非加密库，追踪的方式和上面类似的。</p><p>对于 gRPC 这种默认加密的库，Beyla 会通过 eBPF 对<code>header_writeSubset</code>进行 Hook。当服务在调用<code>header_writeSubset</code>写入 HTTP Header 时，eBPF 会查询<code>traceparent id</code>并写入 Go 用户态内存中。以此来实现对加密流量的上下文追踪。</p><h1 id=参考文档>参考文档</h1><ul><li><p><a class=link href=https://grafana.com/docs/beyla/latest/ target=_blank rel=noopener>Grafana Beyla | Grafana Beyla documentation</a></p></li><li><p><a class=link href=https://github.com/grafana/beyla target=_blank rel=noopener>GitHub - grafana/beyla: eBPF-based autoinstrumentation of web applications and network metrics</a></p></li></ul></section><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0}),document.addEventListener("DOMContentLoaded",function(){var e=document.querySelectorAll("pre code.language-mermaid");e.forEach(function(e){var n,t=document.createElement("div");t.className="mermaid",t.innerHTML=e.textContent,n=e.parentElement,n.parentNode.replaceChild(t,n)})})</script><footer class=article-footer><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/blog/p/beyla-%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/><div class=article-details><h2 class=article-title>Beyla 功能介绍</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Wlynxg's Blog</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/blog/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>