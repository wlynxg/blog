<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><follow_challenge><feedId>77250260013802496</feedId><userId>42117541714060288</userId></follow_challenge><title>操作系统 on Wlynxg's Blog</title><link>https://wlynxg.github.io/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link><description>Recent content in 操作系统 on Wlynxg's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 22 Aug 2025 17:34:52 +0800</lastBuildDate><atom:link href="https://wlynxg.github.io/blog/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>1.1 操作系统的基本概念</title><link>https://wlynxg.github.io/blog/p/1.1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/1.1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="11-操作系统的基本概念">1.1 操作系统的基本概念
&lt;/h1>&lt;h2 id="知识图谱">知识图谱
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140129.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一操作系统的概念">一、操作系统的概念
&lt;/h2>&lt;p>计算机系统自下而上大致可以分为四个部分：&lt;strong>硬件、操作系统、应用程序和用户&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>操作系统（Operating System，OS）是指控制和管理整个计算机系统的硬件与软件资源，合理地组织、调度计算机的工作与资源的分配，进而为用户和其它软件提供方便接口与环境的程序集合。操作系统管理各种计算机硬件，为应用程序提供基础，并充当计算机硬件与用户之间的中介，是随着计算机研究和应用的发展逐步形成并发展起来的，它是计算机系统中&lt;strong>最基本的系统软件&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;h2 id="二操作系统的特征">二、操作系统的特征
&lt;/h2>&lt;p>操作系统的基本特征包括&lt;strong>并发、共享、虚拟和同步&lt;/strong>。&lt;/p>
&lt;h3 id="1-并发concurrence">1. 并发（Concurrence）
&lt;/h3>&lt;blockquote>
&lt;p>并发指两个或多个事件在同一时间间隔内发生。操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。在操作系统中，引入进程的目的是使程序能够并发执行。&lt;/p>
&lt;/blockquote>
&lt;p>注意并发（Concurrence）和并行（Parallelism）的区别：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>并发（Concurrence）&lt;/strong>：一个处理器同时处理多个任务，指的是逻辑上的同时发生；&lt;/li>
&lt;li>&lt;strong>并行（Parallelism）&lt;/strong>：多个处理器或者是多核的处理器同时处理多个不同的任务，指的是物理上的同时发生。&lt;/li>
&lt;/ul>
&lt;h3 id="2-共享sharing">2. 共享（Sharing）
&lt;/h3>&lt;p>资源共享即共享，其指的是系统中的资源可供内存中多个并发执行的进程共同使用。共享可以分为&lt;strong>互斥共享&lt;/strong>方式和&lt;strong>同时共享&lt;/strong>方式。&lt;/p>
&lt;h4 id="互斥共享方式">互斥共享方式
&lt;/h4>&lt;p>系统中的某些资源，例如打印机，虽然可以供多个并发执行的进程使用，但是为了避免这个进程打印一点那个进程打印一点这种资源使用混乱的情况，操作系统规定在&lt;strong>一段时间内只允许一个进程访问该资源&lt;/strong>。这种共享资源的方式就是&lt;strong>互斥共享&lt;/strong>，这种一段时间内只允许一个进程访问的资源被称为&lt;strong>临界资源或者独占资源&lt;/strong>。&lt;/p>
&lt;p>在进程 A 访问临界资源时，必须先向操作系统提出访问请求，若此时该资源空闲，则操作系统将该资源分配给进程 A 使用，此后其它进程想要访问该资源就必须等待，直到进程 A 访问完毕并释放该资源后其它进程才能访问该资源。&lt;/p>
&lt;p>计算机系统中的大部分物理设备及某些软件中所用的栈、变量和表格都属于临界资源，它们都被要求互斥地共享。&lt;/p>
&lt;h4 id="同时共享方式">同时共享方式
&lt;/h4>&lt;p>计算机中的某个资源在在一段时间内可以同时允许多个进程访问，这种资源访问方式就称为同时共享。&lt;/p>
&lt;p>同时共享通常要求一个请求分为几个时间片段间隔的完成，即交替进行，“分时共享”。因此这里的“同时”指的是宏观上的，在微观上依然是交替进行的。只是由于 CPU 执行速度很快，我们感觉不到交替罢了。&lt;/p>
&lt;p>例如我们一边打游戏一边听歌的行为，游戏和音乐播放器是两个不同的进程，但是他们可以同时占用音频播放设备。因此我们才能够既听到音乐又听到游戏声音。&lt;/p>
&lt;p>并发和共享式操作系统两个最基本的特征，两者之间互为存在的条件：&lt;/p>
&lt;ul>
&lt;li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则不会存在资源共享的问题；&lt;/li>
&lt;li>若系统不能对资源共享实施有效的管理，则必将会影响到程序的并发执行。&lt;/li>
&lt;/ul>
&lt;h3 id="3-虚拟virtual">3. 虚拟（Virtual）
&lt;/h3>&lt;blockquote>
&lt;p>虚拟是指把一个物理上的实体变为若干逻辑上的对应物体。物理实体是“实”的，是实际存在的；而对应物是“虚”的，是逻辑上构建出来的。&lt;strong>用于实现虚拟的技术称为虚拟技术&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;p>操作系统中利用了多种虚拟技术来实现虚拟处理器、虚拟内存和虚拟外部设备等，包括现在使用的 Docker 和 K8S 同样是利用虚拟技术实现的。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序&lt;/strong>，使它们在管理程序控制下，相互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计算机系统资源。与之相对应的是单道程序，即在计算机内存中只允许一个的程序运行。&lt;/p>
&lt;/blockquote>
&lt;p>下面简单介绍以下几种虚拟技术：&lt;/p>
&lt;ul>
&lt;li>**虚拟处理器技术：**它是通过多道程序设计，采用让多道程序并发执行的方法，分时使用一个处理器。虽然只有一个物理处理器，但是能同时为多个用户使用，让每个终端用户都感觉到有一个 CPU 在为自己服务。利用多道程序设计技术把一个物理上的 CPU 虚拟为多个逻辑上的虚拟 CPU，称为虚拟处理器；&lt;/li>
&lt;li>&lt;strong>虚拟存储器技术&lt;/strong>：虚拟储存器技术可以把一台机器的物理存储器变为虚拟存储器，从而在逻辑上扩充物理存储器的容量。用户感觉到的存储器称之为虚拟存储器。例如电脑上安装了一个 8GB 的内存条，由于虚拟存储技术可以衍生出多个虚拟存储器，操作系统让每个进程都在虚拟存储器上运行，于是乎每个进程都感觉自己独占了 8GB 的内存，而实际上是他们共同使用那 8GB 的物理内存；&lt;/li>
&lt;li>&lt;strong>虚拟设备技术&lt;/strong>：将一台物理 I/O 设备虚拟为多台逻辑上的 I/O 设备，并允许每个用户占用一台逻辑上的 I/O 设备。使原来仅允许在一段时间由一个用户访问的临界资源变成了一段时间内允许多个用户访问的共享资源。&lt;/li>
&lt;/ul>
&lt;p>操作系统的虚拟技术可以归纳为：&lt;strong>时分复用技术&lt;/strong>，如处理器的分时共享；&lt;strong>空分复用技术&lt;/strong>，如虚拟存储器技术。&lt;/p>
&lt;h3 id="4-异步asynchronism">4. 异步（Asynchronism）
&lt;/h3>&lt;blockquote>
&lt;p>多道程序环境允许多个程序并发执行，但是由于系统资源有限，进程的执行是走走停停的，它以不可预知的速度向前运行，这就是程序的异步性。&lt;/p>
&lt;/blockquote>
&lt;p>只有操作系统拥有并发性才会拥有异步性。&lt;/p>
&lt;p>异步性使得操作系统运行在一种随机的环境下，可能会导致进程产生与时间有关的错误（例如对全局变量的访问不当会导致程序出现错误）。但是只要运行环境相同，操作系统必须保证运行结果相同。&lt;/p>
&lt;h2 id="三操作系统的目标和功能">三、操作系统的目标和功能
&lt;/h2>&lt;blockquote>
&lt;p>为了给多道程序提供良好的运行环境，操作系统应当具有以下几个方面的功能：&lt;strong>处理机管理、存储器管理、设备管理和文件管理&lt;/strong>；&lt;/p>
&lt;p>为了方便用户使用操作系统，还必须&lt;strong>向用户提供接口&lt;/strong>。&lt;/p>
&lt;/blockquote>
&lt;h3 id="1-计算机系统资源的管理者">1. 计算机系统资源的管理者
&lt;/h3>&lt;h4 id="1处理机管理">（1）处理机管理
&lt;/h4>&lt;p>在多道程序环境下，处理机的分配和运行都以进程（或线程）为基本单位。因而对处理机的管理实际上为对进程的管理。&lt;/p>
&lt;p>进程管理主要包括：&lt;strong>进程控制、进程同步、进程通信、死锁处理和处理机调度等&lt;/strong>。&lt;/p>
&lt;h4 id="2存储器管理">（2）存储器管理
&lt;/h4>&lt;p>存储器管理是为了给多道程序的运行提供良好的环境，方便用户使用及提高内存的利用率。&lt;/p>
&lt;p>存储器管理主要包括：&lt;strong>内存分配、地址映射、内存保护与共享和内存扩充等&lt;/strong>。&lt;/p>
&lt;h4 id="3文件管理">（3）文件管理
&lt;/h4>&lt;p>计算机中的信息都是以文件形式存在的，操作系统中负责文件管理的部分称为&lt;strong>文件系统&lt;/strong>。&lt;/p>
&lt;p>文件管理主要包括：&lt;strong>存储空间的管理、目录的管理以及文件读写管理和保护等&lt;/strong>。&lt;/p>
&lt;h4 id="4设备管理">（4）设备管理
&lt;/h4>&lt;p>设备管理的主要任务是完成用户的 I/O 请求，方便用户使用各种设备并提高设备的利用率。&lt;/p>
&lt;p>设备管理主要包括：&lt;strong>缓冲管理、设备分配、设备处理和虚拟设备等&lt;/strong>。&lt;/p>
&lt;h3 id="2-用户与计算机硬件系统之间的接口">2. 用户与计算机硬件系统之间的接口
&lt;/h3>&lt;p>为了方便用户使用计算机，操作系统还提供了用户接口。&lt;/p>
&lt;p>操作系统提供的接口主要分为两类：&lt;strong>命令接口&lt;/strong>，用户使用命令接口来组织和控制作业的执行；&lt;strong>程序接口&lt;/strong>，程序员使用程序接口来请求操作系统服务。&lt;/p>
&lt;h4 id="1命令接口">（1）命令接口
&lt;/h4>&lt;p>使用命令接口进行作业控制的主要方式有两种：&lt;strong>联机控制方式&lt;/strong>和&lt;strong>脱机控制方式&lt;/strong>。按照控制方式可以将命令接口分为&lt;strong>联机命令接口&lt;/strong>和&lt;strong>脱机命令接口&lt;/strong>。&lt;/p>
&lt;h5 id="联机命令接口">联机命令接口
&lt;/h5>&lt;p>&lt;strong>联机命令接口又称为交互式命令接口&lt;/strong>，适用于分时或者实时系统的接口。&lt;/p>
&lt;p>用户通过控制台或者终端输入操作命令。&lt;/p>
&lt;p>用户每输入一条命令，控制权就转交给操作系统的命令解释程序，然后由命令解释程序解释并执行输入的命令，等到完成功能后控制权再转交给用户。&lt;/p>
&lt;h5 id="脱机命令接口">脱机命令接口
&lt;/h5>&lt;p>&lt;strong>脱机命令接口又称为批处理命令接口&lt;/strong>，适用于批处理系统。&lt;/p>
&lt;p>它由一组作业控制命令组成。脱机用户不能直接干预程序的运行，而应事先用相应的作业控制命令写成一份作业操作说明书，连同作业一起提交给操作系统。系统调度到该作业时，由系统中的命令解释器逐步解释并执行作业操作说明书上的命令或者作业控制语句，从而间接的控制作业的运行。&lt;/p>
&lt;p>例如将下面的程序保存为 &lt;code>.bat&lt;/code> 后缀的文本，在 Windows 系统下运行就可以批量创建文件夹。这个 &lt;code>xxx.bat&lt;/code> 程序就是一个作业操作说明书，里面的代码就是批处理命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">md folder1 folder2 folder3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="2程序接口">（2）程序接口
&lt;/h4>&lt;p>程序接口由一组系统调用命令（简称系统调用，也称广义接口）组成。&lt;/p>
&lt;p>用户通过在程序中使用这些系统调用命令来请求操作系统为其提供服务，如使用外部设备、进行磁盘操作等。&lt;/p>
&lt;p>当前最为流行的图形用户界面 GUI（Graphical User Interface，即图形接口）并不是操作系统的一部分，但是图形接口调用的系统调用命令是操作系统的一部分。&lt;/p>
&lt;h3 id="3-用作扩充器">3. 用作扩充器
&lt;/h3>&lt;p>没有任何软件支持的计算机称为裸机，它仅仅构成计算机系统的物质基础。&lt;/p>
&lt;p>操作系统提供的资源管理功能和方便用户的各种服务功能，将裸机改造成功能更强、使用更方便的机器。&lt;/p>
&lt;p>因此我们通常&lt;strong>把覆盖了软件的机器称为扩充机器或虚拟机&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>参考资料：王道考研——操作系统&lt;/p>
&lt;/blockquote></description></item><item><title>1.2 操作系统的发展与分类</title><link>https://wlynxg.github.io/blog/p/1.2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/1.2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E4%B8%8E%E5%88%86%E7%B1%BB/</guid><description>&lt;h1 id="12-操作系统的发展与分类">1.2 操作系统的发展与分类
&lt;/h1>&lt;h2 id="知识图谱">知识图谱
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140149.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一手工操作阶段此阶段无操作系统">一、手工操作阶段（此阶段无操作系统）
&lt;/h2>&lt;p>穿孔纸带是早期计算机的输入和输出设备，它将程序和数据转换二进制数码：带孔为1，无孔为0，经过光电扫描输入电脑。然后人们在运行程序时就将打满小孔的纸带输入到计算机。计算机上的所有工作都需要用户干预，人机矛盾越来越大，因此必须寻找新的解决方案。&lt;/p>
&lt;p>手工操作阶段有两个突出的缺点：&lt;/p>
&lt;ul>
&lt;li>用户独占全机，资源利用率低，但是不会出现其它用户占据资源的情况；&lt;/li>
&lt;li>CPU 等待手工操作，CPU 的利用不充分。&lt;/li>
&lt;/ul>
&lt;h2 id="二批处理阶段操作系统开始出现">二、批处理阶段（操作系统开始出现）
&lt;/h2>&lt;p>为了解决人机矛盾以及 CPU 和 I/O 设备之间速度不匹配的矛盾，出现了批处理系统。按发展例程又可以分为&lt;strong>单道批处理系统&lt;/strong>和&lt;strong>多道批处理系统&lt;/strong>。&lt;/p>
&lt;h3 id="1-单道批处理系统">1. 单道批处理系统
&lt;/h3>&lt;p>单道批处理系统对作业的处理是批量进行的，但是内存中始终仅存在一道作业。&lt;/p>
&lt;p>单道批处理系统的主要特征有以下几个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自动性&lt;/strong>：正常情况下磁带上的作业能够自动逐个运行，无需人工干预；&lt;/li>
&lt;li>&lt;strong>顺序性&lt;/strong>：磁带上的各道作业完成顺序和它们进入内存的顺序相同；&lt;/li>
&lt;li>&lt;strong>单道性&lt;/strong>：内存中仅有一条作业在运行。&lt;/li>
&lt;/ul>
&lt;p>单道批处理系统面临的问题是：主机内存中仅存放一条批处理任务，每当它在运行期间发出输入/输出请求后，高速的 CPU 便会进入等待低速的 I/O 设备的状态。&lt;/p>
&lt;h3 id="2-多道批处理系统">2. 多道批处理系统
&lt;/h3>&lt;p>多道程序设计技术运行多个程序同时进入内存中并且在 CPU 上交替运行，这些程序可以共享系统中的所有资源。&lt;/p>
&lt;p>当一个程序因为 I/O 请求而暂停时，CPU 便可立即转去运行另外的程序。它不采用某种机制来提高某一方面的瓶颈问题，而让系统的各个组成部分都尽量进入使用状态。虽然切换任务会花费一定的时间，但是可以实现系统间各个部件的并行工作，使整体在单位时间内的效率翻倍。&lt;/p>
&lt;p>多道批处理系统有着以下特点：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>多道&lt;/strong>：计算机内存中同时放入多道相互独立的程序；&lt;/li>
&lt;li>&lt;strong>宏观上并行&lt;/strong>：进入内存中的所有程序都处于运行状态；&lt;/li>
&lt;li>&lt;strong>微观上串行&lt;/strong>：内存中的多道程序轮流占用 CPU，交替执行。&lt;/li>
&lt;/ul>
&lt;p>多道程序设计技术的实现需要解决下面几个问题：&lt;/p>
&lt;ul>
&lt;li>如何分配处理器？&lt;/li>
&lt;li>多道程序的内存如何分配？&lt;/li>
&lt;li>I/O 设备如何分配？&lt;/li>
&lt;li>如何组织和存放大量的程序和数据？&lt;/li>
&lt;/ul>
&lt;p>多道批处理系统的优缺点：&lt;/p>
&lt;ul>
&lt;li>优点：
&lt;ul>
&lt;li>资源利用率高；&lt;/li>
&lt;li>系统吞吐量大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>缺点：
&lt;ul>
&lt;li>用户响应时间长；&lt;/li>
&lt;li>不提供人机交互。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="三分时操作系统">三、分时操作系统
&lt;/h2>&lt;blockquote>
&lt;p>分时技术：把处理机的运行时间分为很短的时间片，按时间片轮流把处理机分给各联机作业使用；如果某个作业在分配给他的时间片用完之前计算还未完成，该作业就暂时中断，等待下一轮继续计算。此时处理机让给另一个作业使用。&lt;/p>
&lt;/blockquote>
&lt;p>在操作系统中采用分时技术便形成了分时系统。分时操作系统允许多个用户通过终端同时共享同一台主机，用户可以同时与主机交互而互不干扰。因此实现分时系统最关键的问题就是如何使用户能与自己的作业交互。&lt;/p>
&lt;p>分时操作系统同样支持多道程序设计，但它不同于多道批处理系统，分时操作系统允许人机交互，而多道批处理系统不允许人机交互。&lt;/p>
&lt;p>分时操作系统有如下特征：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>同时性&lt;/strong>：同时性又称多路性，指允许多个终端用户同时使用一台计算机；&lt;/li>
&lt;li>&lt;strong>交互性&lt;/strong>：用户能够通过终端采用人机对话的方式直接控制计算机；&lt;/li>
&lt;li>&lt;strong>独立性&lt;/strong>：系统中多个用户可以彼此独立地操作，互不影响；&lt;/li>
&lt;li>&lt;strong>及时性&lt;/strong>：用户请求能在短时间内得到回应。&lt;/li>
&lt;/ul>
&lt;h2 id="四实时操作系统">四、实时操作系统
&lt;/h2>&lt;p>为了能够在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。&lt;/p>
&lt;p>这里地时间限制分为两种情况：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>硬实时系统&lt;/strong>：某个动作必须绝对地在规定的时刻（或者规定的时间范围）发生；&lt;/li>
&lt;li>&lt;strong>软实时系统&lt;/strong>：任务能够接受偶尔违反时间规定且不会引起任何永久性的损坏。&lt;/li>
&lt;/ul>
&lt;p>实时操作系统的特点主要是&lt;strong>及时性&lt;/strong>和&lt;strong>可靠性&lt;/strong>。&lt;/p>
&lt;h2 id="五网络操作系统和分布式计算机系统">五、网络操作系统和分布式计算机系统
&lt;/h2>&lt;p>网络操作系统把计算机网络中的各台计算机有机地结合起来形成一个整体，提供一种统一、经济而有效地使用各台计算机地方法，实现各台计算机之间数据地相互传送。网络操作系统地主要特点是网络中各种&lt;strong>资源的共享&lt;/strong>以及各台&lt;strong>计算机之间的通信&lt;/strong>。&lt;/p>
&lt;p>分布式计算机系统是由多台计算机组成并满足下列条件的系统：&lt;/p>
&lt;ul>
&lt;li>系统中任意两台计算机通过通信方式交换信息；&lt;/li>
&lt;li>系统中的每台计算机都具有同等的地位，没有主从之分；&lt;/li>
&lt;li>每台计算机上的资源为所有用户共享；&lt;/li>
&lt;li>系统中任意台计算机都可以构成一个子系统，并且可以重构；&lt;/li>
&lt;li>任何工作都可以分布在几台计算机上，由它们并行、协同完成。&lt;/li>
&lt;/ul>
&lt;p>用于管理分布式计算机系统的操作系统称为分布式计算机系统，其和网络操作系统的本质不同是：同一任务由分布式操作系统中的若干计算机协调完成。&lt;/p>
&lt;p>分布式计算机系统主要特点为&lt;strong>分布性&lt;/strong>和&lt;strong>并行性&lt;/strong>。&lt;/p>
&lt;h2 id="六个人计算机操作系统">六、个人计算机操作系统
&lt;/h2>&lt;p>个人计算机系统是目前使用最为广泛的系统，常见的有 Windows、Linux、Mac OS等。&lt;/p>
&lt;blockquote>
&lt;p>参考资料：王道考研——操作系统&lt;/p>
&lt;/blockquote></description></item><item><title>1.3 操作系统的运行环境</title><link>https://wlynxg.github.io/blog/p/1.3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/1.3-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/</guid><description>&lt;h1 id="13-操作系统的运行环境">1.3 操作系统的运行环境
&lt;/h1>&lt;h2 id="知识图谱">知识图谱
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140216.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一操作系统的运行机制">一、操作系统的运行机制
&lt;/h2>&lt;p>计算机系统中，通常 CPU 执行两种不同性质的程序：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>操作系统内核程序&lt;/strong>：通常会执行一些&lt;strong>特权指令&lt;/strong>（指计算机中不允许用户直接执行的指令，如中断指令，这些指令必须由操作系统调度执行），&lt;/li>
&lt;li>&lt;strong>用户自编程序&lt;/strong>：主要执行&lt;strong>非特权指令&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>在具体实现上，将 CPU 状态划分为用户态（目态）和核心态（管态、内核态）。当 CPU 处于用户态时，&lt;strong>只能执行非特权指令&lt;/strong>；当 CPU 处于核心态时，CPU &lt;strong>既可以执行特权指令也可以执行非特权指令&lt;/strong>。&lt;strong>用户自编程序运行在用户态，操作系统内核程序运行在核心态&lt;/strong>。&lt;/p>
&lt;p>现代操作系统几乎都是层次式的结构：&lt;/p>
&lt;ul>
&lt;li>与硬件关联较高的模块，如时钟关联、中断处理，处于最低层；&lt;/li>
&lt;li>运行频率高的程序，如进程关联、存储器管理，位于上一层。&lt;/li>
&lt;/ul>
&lt;p>这两部分构成了操作系统的内核，都运行在核心态。&lt;/p>
&lt;p>大多数操作系统内核包含以下方面：&lt;/p>
&lt;h3 id="1-时钟管理">1. 时钟管理
&lt;/h3>&lt;p>在操作系统中时钟的功能主要有两大类：&lt;/p>
&lt;ul>
&lt;li>向用户提供系统时间；&lt;/li>
&lt;li>通过时钟中断的管理，实现进程的切换。&lt;/li>
&lt;/ul>
&lt;h3 id="2-中断机制">2. 中断机制
&lt;/h3>&lt;p>引入中断技术的最初目的是提高多道环境中 CPU 的利用率。&lt;/p>
&lt;p>后来随着现代操作系统的发展，中断成为了操作系统各项操作的基础，如鼠标键盘信息的输入、进程的管理与调度、文件访问等。可以说现代操作系统是依靠中断驱动的软件。&lt;/p>
&lt;p>中断机制中，只由小部分是属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断处理时间，提高 CPU 利用率。&lt;/p>
&lt;h3 id="3-原语">3. 原语
&lt;/h3>&lt;p>按层次结构设计的操作系统，底层必然是一些可以被调用的公用小程序，它们各自完成一个规定的操作。它们拥有如下特点：&lt;/p>
&lt;ul>
&lt;li>处于操作系统底层，是最接近硬件的部分；&lt;/li>
&lt;li>程序运行具有原子性；&lt;/li>
&lt;li>程序运行时间短，调用频繁。&lt;/li>
&lt;/ul>
&lt;p>通常把具有这些特点的程序称为原语（Atomic Operation）。定义原语的直接方法是关闭中断，让所有动作都不可分割的完成后再打开中断。&lt;/p>
&lt;h3 id="4-系统控制的数据结构及处理">4. 系统控制的数据结构及处理
&lt;/h3>&lt;p>系统中用来登记状态信息的数据结构有很多，为了实现有效的管理，系统需要一些基本的操作。常见操作有以下几个：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>进程管理&lt;/strong>：进程状态管理、进程调度和分派、创建与撤销进程控制块等；&lt;/li>
&lt;li>&lt;strong>存储器管理&lt;/strong>：存储器的空间分配和回收、内存信息保护程序、代码对换程序等；&lt;/li>
&lt;li>&lt;strong>设备管理&lt;/strong>：缓冲区管理、设备分配和回收等。&lt;/li>
&lt;/ul>
&lt;p>从上述内容可以发现，核心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。&lt;/p>
&lt;h2 id="二中断和异常的概念">二、中断和异常的概念
&lt;/h2>&lt;p>为了实现 CPU 用户态和核心态的切换，在 CPU 核心态建立了通道， 以便实现从用户态进入核心态。在实际操作系统中，CPU 运行上层程序时&lt;strong>唯一能进入这些通道的途径就是通过中断和异常&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>中断（Interruption）也称外中断&lt;/strong>，指来自 CPU 指令以外的事情发生。例如 I/O 设备结束中断表示设备输入/输出完成，希望处理机能够向设备发下一个输入/输出请求，同时让程序继续运行。&lt;/p>
&lt;p>时钟中断，表示一个固定的时间片已到，让处理机处理计时、启动定时任务等。这一类中断通常与当前程序运行无关的事情。&lt;/p>
&lt;p>&lt;strong>异常（Exception）也称内中断、例外和陷入（trap）&lt;/strong>，指源自 CPU 执行指令内部的事件，如地址越界、算术溢出、虚存系统的缺页及专门的陷入指令等引起的事件。关于异常的处理一般要依赖于当前程序的运行现场，而且异常通常不能被屏蔽，&lt;strong>一旦出现必须立即处理&lt;/strong>。&lt;/p>
&lt;h2 id="三系统调用">三、系统调用
&lt;/h2>&lt;p>所谓系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公告子程序。&lt;/p>
&lt;p>这些系统调用按功能大致可以分为如下几类：&lt;/p>
&lt;ul>
&lt;li>设备管理：完成设备的请求或释放，以及设备启动等功能；&lt;/li>
&lt;li>文件管理：完成文件的读、写、创建以及删除等功能；&lt;/li>
&lt;li>进程管理：完成进程的创建、撤销、阻塞及唤醒等功能；&lt;/li>
&lt;li>进程通信：完成进程之间的消息传递或信号传递等功能；&lt;/li>
&lt;li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及初始地址等功能。&lt;/li>
&lt;/ul>
&lt;p>用户程序不能直接执行对系统影响飞车大的操作，必须通过系统调用的方式请求操作系统代为执行，以便提高系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其它进程的执行。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-214637.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;p>在操作系统层面上我们关心的是系统核心态和用户态的软件实现与切换。&lt;/p>
&lt;p>列举一些由用户态转向核心态的例子：&lt;/p>
&lt;ul>
&lt;li>用户程序要求操作系统的服务，即系统调用；&lt;/li>
&lt;li>发生了一次中断；&lt;/li>
&lt;li>用户程序中产生了一个错误状态；&lt;/li>
&lt;li>用户程序试图执行一条特权指令；&lt;/li>
&lt;li>从核心态转为用户态也是由特权指令产生，一般是中断返回指令。&lt;/li>
&lt;/ul>
&lt;p>由用户态转为核心态，不仅仅要切换状态，所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但是系统堆栈也是属于该进程的。&lt;/p>
&lt;p>如程序运行由用户态转为核心态，就会用到访管指令，访管指令是在用户态使用的，因此它是非特权指令。&lt;/p>
&lt;blockquote>
&lt;p>参考资料：王道考研——操作系统&lt;/p>
&lt;/blockquote></description></item><item><title>1.4 操作系统的体系结构</title><link>https://wlynxg.github.io/blog/p/1.4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/1.4-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="14-操作系统的体系结构">1.4 操作系统的体系结构
&lt;/h1>&lt;p>操作系统主要有两种体系结构：&lt;strong>大内核&lt;/strong>与&lt;strong>微内核&lt;/strong>。&lt;/p>
&lt;h2 id="大内核">大内核
&lt;/h2>&lt;p>大内核系统将操作系统的主要功能模块都作为一个紧密联系的整体运行在核心态，从而为应用提供高性能的系统服务。因为各个管理模块之间共享信息，能够有效利用相互之间的有效特性，所以&lt;strong>具有无可比拟的性能优势&lt;/strong>。&lt;/p>
&lt;p>但是随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越多，而且接口也越来越复杂，导致操作系统的设计规模急剧增长。&lt;/p>
&lt;h2 id="微内核">微内核
&lt;/h2>&lt;p>为解决操作系统的内核代码难以维护的问题，提出了微内核的体系结构。&lt;/p>
&lt;p>微内核将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行，大大降低了内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分为若干个服务程序，它们的执行相互独立，交互则借助于微内核进行通信。&lt;/p>
&lt;p>微内核结构有效地分离了内核与服务、服务与服务，使得它们之间的接口更加清晰，维护的代价大大降低，各部分可以独立地进行优化和演进，从而保证操作系统地可靠性。&lt;/p>
&lt;p>&lt;strong>微内核的最大问题在于性能&lt;/strong>，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。&lt;/p>
&lt;p>为减少开销，也有人提出将系统服务作为运行库链接到用户程序，这样的体系结构称为&lt;strong>库操作系统&lt;/strong>。&lt;/p>
&lt;hr>
&lt;blockquote>
&lt;p>参考资料：王道考研——操作系统&lt;/p>
&lt;/blockquote></description></item><item><title>2.1 进程与线程</title><link>https://wlynxg.github.io/blog/p/2.1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/2.1-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</guid><description>&lt;h1 id="21-进程与线程">2.1 进程与线程
&lt;/h1>&lt;h2 id="思维导图">思维导图
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140241.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一进程的概念和特征">一、进程的概念和特征
&lt;/h2>&lt;h3 id="进程的概念">进程的概念
&lt;/h3>&lt;p>在多道程序环境下，运行多个程序并发执行，此时它们将失去封闭性，并具有间断性以及不可再现性的特征。为此引入了&lt;strong>进程（Process）&lt;strong>的概念，以便更好的秒数和控制程序的并发执行，实现操作系统的&lt;/strong>并发性&lt;/strong>与&lt;strong>共享性&lt;/strong>。&lt;/p>
&lt;p>为了使参与并发执行的程序（含数据）能够独立地运行，必须为之配置一个专门地数据结构，称之为&lt;strong>进程控制块（Process Control Block，PCB）&lt;/strong>。系统利用 PCB 来描述进程地基本情况和运行态，进而控制和管理进程。由&lt;strong>程序段、数据段和 PCB 组成进程映像（进程实体）&lt;/strong>。要注意&lt;strong>进程映像是动态的&lt;/strong>，而&lt;strong>进程是静态的&lt;/strong>，进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。&lt;/p>
&lt;p>所谓创建进程，实质上是创建进程映像中地 PCB；而撤销进程，实质上是撤销进程地 PCB。&lt;/p>
&lt;p>进程有着如下定义：&lt;/p>
&lt;ul>
&lt;li>进程是程序的一次执行过程；&lt;/li>
&lt;li>进程是一个程序及数据在处理机上顺序执行时所发生的活动；&lt;/li>
&lt;li>进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。&lt;/li>
&lt;/ul>
&lt;h3 id="进程的特征">进程的特征
&lt;/h3>&lt;p>进程是由多程序的并发执行而引出的，它和程序是两个截然不同的概念。&lt;/p>
&lt;p>进程的基本特征是对比单个程序的执行提出的，也是对进程管理提出的基本要求：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>动态性（最基本的特征）&lt;/strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的；&lt;/li>
&lt;li>**并发性：**指多个进程实体同时存在于内存中。引入进程的目的就是为了使程序能与其他进程的程序并发执行，以提高资源利用率；&lt;/li>
&lt;li>**独立性：**指进程实体使一个能够独立运行、独立获得资源和独立接受调度的基本单位。凡是未建立 PCB 的程序，都不能作为一个独立的单位参与运行；&lt;/li>
&lt;li>**异步性：**由于进程的相互制约，进程具有执行的间断性。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应进程的同步机制；&lt;/li>
&lt;li>**结构性：**从结构上来看，进程实体是由程序段、数据段和 PCB 共同组成的。&lt;/li>
&lt;/ul>
&lt;h2 id="二进程的状态与转换">二、进程的状态与转换
&lt;/h2>&lt;h3 id="五种基本状态">五种基本状态
&lt;/h3>&lt;p>通常进程有以下五种状态，前三种是进程的基本状态：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>运行态&lt;/strong>：进程正在处理机上运行，每个 CPU 每个时刻最多只有一个进程处于运行状态；&lt;/li>
&lt;li>&lt;strong>就绪态&lt;/strong>：进程处于已准备运行的状态，进程此时已经获得了除处理机以外的以切资源；&lt;/li>
&lt;li>&lt;strong>阻塞态&lt;/strong>（又称等待态）：进程正在等待某一事件而暂停运行，例如等待资源可用，此时即使处理机空闲程序也不能运行；&lt;/li>
&lt;li>&lt;strong>创建态&lt;/strong>：进程正在被创建，尚未转到就绪态；&lt;/li>
&lt;li>&lt;strong>结束态&lt;/strong>：进程正在从系统中消失。&lt;/li>
&lt;/ul>
&lt;h3 id="状态转换">状态转换
&lt;/h3>&lt;p>三种基本状态的转换如下：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>就绪态 -&amp;gt; 运行态&lt;/strong>：处于就绪态的进程被调度后，获得处理机资源；&lt;/li>
&lt;li>&lt;strong>运行态 -&amp;gt; 就绪态&lt;/strong>：处于运行态的进程在时间片用完后，必须让出处理机，从而进程由运行态转换为就绪态；&lt;/li>
&lt;li>&lt;strong>运行态 -&amp;gt; 阻塞态&lt;/strong>：进程请求某一资源的使用和分配情况等待某一事件的发生时，它就从运行态转换为阻塞态；&lt;/li>
&lt;li>&lt;strong>阻塞态 -&amp;gt; 就绪态&lt;/strong>：进程等待的事件到来时，中断程序必须把进程的状态由阻塞态转换为就绪态。&lt;/li>
&lt;/ul>
&lt;p>注意：进程从&lt;strong>运行态转换为阻塞态是主动的行为&lt;/strong>，从&lt;strong>阻塞态转换为就绪态是被动的行为&lt;/strong>，需要相关进程的协助。&lt;/p>
&lt;h2 id="三进程控制">三、进程控制
&lt;/h2>&lt;p>进程控制的主要功能是&lt;strong>对系统中的所有进程实施有效的管理&lt;/strong>，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。&lt;/p>
&lt;h3 id="1-进程的创建">1. 进程的创建
&lt;/h3>&lt;p>操作系统允许一个进程创建另外一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程的拥有的所有资源。当子进程被撤销时，应将其从父进程那里获得的所有资源归还给父进程。在父进程被撤销时，必须同时撤销所有的子进程。&lt;/p>
&lt;p>操作系统创建一个新进程（创建原语）的过程如下：&lt;/p>
&lt;ul>
&lt;li>为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB（PCB 是有限的），若申请失败则创建失败；&lt;/li>
&lt;li>为进程分配资源，为新进程的程序和数据及用户栈分配必要的内存空间（PCB 中体现）。如果资源不足则进入等待状态；&lt;/li>
&lt;li>初始化 PCB，；&lt;/li>
&lt;li>若进程就绪队列能够接纳新进程，则将新进程插入队列，等待调度运行。&lt;/li>
&lt;/ul>
&lt;h3 id="2-进程的终止">2. 进程的终止
&lt;/h3>&lt;p>引起进程终止的事件主要有：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>正常结束&lt;/strong>：进程的任务已经完成并准备退出运行；&lt;/li>
&lt;li>&lt;strong>异常结束&lt;/strong>：进程在运行时，发生了某种异常事件，使进程无法正常运行；&lt;/li>
&lt;li>&lt;strong>外界干预&lt;/strong>：进程应外界的请求而终止运行。&lt;/li>
&lt;/ul>
&lt;p>操作系统终止进程（撤销原语）的过程如下：&lt;/p>
&lt;ul>
&lt;li>根据被终止进程的标识符，检索 PCB，从而读出进程状态；&lt;/li>
&lt;li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其它进程；&lt;/li>
&lt;li>若该进程还有子进程，则终止所有子进程；&lt;/li>
&lt;li>将进程所占用所有资源归还给父进程或操作系统；&lt;/li>
&lt;li>将该 PCB 从所在队列删除。&lt;/li>
&lt;/ul>
&lt;h3 id="3-进程的阻塞和唤醒">3. 进程的阻塞和唤醒
&lt;/h3>&lt;p>正在执行的进程由于某些期待的事情未发生，如请求系统资源失败等，由系统自动执行阻塞原语（Block），使自己由运行态变为阻塞态。因此可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得 CPU 资源），才可能将其转为阻塞态。&lt;/p>
&lt;p>阻塞原语的执行过程如下：&lt;/p>
&lt;ul>
&lt;li>找到将要被阻塞进程的表示号对应的 PCB；&lt;/li>
&lt;li>若该进程为运行态，则保护其线程，将其状态转化为阻塞态，停止运行；&lt;/li>
&lt;li>把该 PCB 插入相应的等待队列。&lt;/li>
&lt;/ul>
&lt;p>当被阻塞进程所期待的事情出现时，如它所启动的 I/O 操作已完成或其所期待的数据已到达，由有关进程（如提供数据的进程）调用唤醒原语（Wakeup），将等待该事件的进程唤醒。&lt;/p>
&lt;p>唤醒原语的执行过程如下：&lt;/p>
&lt;ul>
&lt;li>在该事情的等待队列中找到相应进程的 PCB；&lt;/li>
&lt;li>将其从等待队列中移出，并置其状态为就绪态；&lt;/li>
&lt;li>把该 PCB 插入就绪队列，等待调度程序调度。&lt;/li>
&lt;/ul>
&lt;p>注意：Block 原语和 Wakeup 原语是一对作用刚好相反的原语，必须成对使用。Block 原语是由被阻塞进程自我调用实现的，而 Wakeup 原语则和一个与被唤醒进程合作或被其它相关的进程调用实现的。&lt;/p>
&lt;h3 id="4-进程切换">4. 进程切换
&lt;/h3>&lt;p>进程切换同样是在内核的支持下实现的，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。&lt;/p>
&lt;p>进程切换的过程如下：&lt;/p>
&lt;ul>
&lt;li>保存处理机上下文，包括程序计数器和其他寄存器；&lt;/li>
&lt;li>更新 PCB 信息；&lt;/li>
&lt;li>把进程的 PCB 移入相应的队列，如就绪、在某事情阻塞等队列；&lt;/li>
&lt;li>选择另一个进程执行，并更新其 PCB；&lt;/li>
&lt;li>更新内存管理的数据结构；&lt;/li>
&lt;li>恢复处理机上下文。&lt;/li>
&lt;/ul>
&lt;p>“调度”和“切换”是有区别的：&lt;/p>
&lt;ul>
&lt;li>调度是指决定资源分配给哪个进程的行为，是一种决策行为；&lt;/li>
&lt;li>切换是指实际分配的行为，是执行行为。&lt;/li>
&lt;/ul>
&lt;p>一般来说，先有资源的调度，然后才有进程的切换。&lt;/p>
&lt;h2 id="四进程的组织">四、进程的组织
&lt;/h2>&lt;p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。&lt;/p>
&lt;h3 id="1-进程控制块">1. 进程控制块
&lt;/h3>&lt;p>进程创建时，操作系统新建一个 PCB 结构，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。PCB 是进程实体的一部分，是进程存在的唯一标志。&lt;/p>
&lt;p>创建一个进程时，系统为该进程建立一个 PCB；进程执行时，系统通过其 PCB 了解进程的现行状态信息，以便对其进行控制和管理；进程结束时，系统收回其 PCB，该进程随之消亡。操作系统通过 PCB表来管理和控制进程。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: center">进程描述信息&lt;/th>
&lt;th style="text-align: center">进程控制和管理信息&lt;/th>
&lt;th style="text-align: center">资源分配清单&lt;/th>
&lt;th style="text-align: center">处理机相关信息&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: center">进程标识符（PID）&lt;/td>
&lt;td style="text-align: center">进程当前状态&lt;/td>
&lt;td style="text-align: center">代码段指针&lt;/td>
&lt;td style="text-align: center">通用寄存器值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">用户标识符（UID）&lt;/td>
&lt;td style="text-align: center">进程优先级&lt;/td>
&lt;td style="text-align: center">数据段指针&lt;/td>
&lt;td style="text-align: center">地址寄存器值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">代码运行入口地址&lt;/td>
&lt;td style="text-align: center">堆栈段指针&lt;/td>
&lt;td style="text-align: center">控制寄存器值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">程序的外存地址&lt;/td>
&lt;td style="text-align: center">文件描述符&lt;/td>
&lt;td style="text-align: center">标值寄存器值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">进入内存时间&lt;/td>
&lt;td style="text-align: center">键盘&lt;/td>
&lt;td style="text-align: center">状态字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">处理机占用时间&lt;/td>
&lt;td style="text-align: center">鼠标&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">信号量使用&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>PCB 主要部分介绍：&lt;/p>
&lt;ul>
&lt;li>进程描述信息：
&lt;ul>
&lt;li>进程标识符：标志各个进程，每个进程都有一个唯一的标识号；&lt;/li>
&lt;li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>进程控制和管理信息：
&lt;ul>
&lt;li>进程当前状态：描述进程的状态信息，作为处理机分配调度的依据；&lt;/li>
&lt;li>进程优先级：描述进程抢占处理机的优先级，优先级高的进程可优先获得处理机。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>资源分配清单：用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息；&lt;/li>
&lt;li>处理机相关信息：主要指处理机中各寄存器的值，当进程被切换时，处理机状态信息都必须保存至相应的 PCB 中，以便在该进程重新执行时，能从断电继续执行。&lt;/li>
&lt;/ul>
&lt;h3 id="2-程序段">2. 程序段
&lt;/h3>&lt;p>程序段就是能被进程调度程序调度到 CPU 执行的程序代码段。程序可被多个进程共享，即多个进程可以运行同一个程序。&lt;/p>
&lt;h3 id="3-数据段">3. 数据段
&lt;/h3>&lt;p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或者最终结果。&lt;/p>
&lt;h2 id="五进程的通信">五、进程的通信
&lt;/h2>&lt;p>进程通信是指进程之间的信息交换。PV 操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方式主要有以下三类：&lt;/p>
&lt;h3 id="1-共享存储">1. 共享存储
&lt;/h3>&lt;p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行对/写操作实现进程之间的信息交换。对共享空间进行写/读操作时，需要使用同步互斥工具（如 P 操作，V 操作），对共享空间的写/读进行控制。&lt;/p>
&lt;p>共享存储又分为两种：&lt;/p>
&lt;ul>
&lt;li>低级的共享是基于数据结构的共享；&lt;/li>
&lt;li>高级的共享是基于存储区的共享。&lt;/li>
&lt;/ul>
&lt;p>操作系统只负责为通信进程提供可供享用使用的存储空间和同步互斥工具，而数据交换则由由用户自己安排读/写指令完成。&lt;/p>
&lt;p>用户进程空间一般都是独立的，进程运行期间一般不能访问其它进程的空间，要想让两个用户进程共享空间，必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。&lt;/p>
&lt;h3 id="2-消息传递">2. 消息传递
&lt;/h3>&lt;p>在消息传递系统中，进程间的数据交换是以格式化的消息（Message）为单位的。若进程间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>直接通信方式&lt;/strong>：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓存队列上，接收进程从消息缓存队列中取得消息；&lt;/li>
&lt;li>&lt;strong>间接通信方式&lt;/strong>：发送进程把消息发送到某个中间实体，接收进程从中间实体获得消息。这种中间实体一般称为信箱，这种通信方式又称信箱通信方式。&lt;/li>
&lt;/ul>
&lt;h3 id="3-管道通信">3. 管道通信
&lt;/h3>&lt;p>管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又称 pipe 文件。&lt;/p>
&lt;p>向管道提供输入的发送进程（写进程），以字符流形式将数据送入管道；接收进程从管道中接收数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>：从管道中读取数据是一次性操作，数据一旦被读取，它就从管道中被抛弃，释放空间以便写更多的数据。管道只能采用半双工通信，要实现父子进程双方互动通信，需要定义两个管道。&lt;/p>
&lt;h2 id="六线程概念和多线程模型">六、线程概念和多线程模型
&lt;/h2>&lt;h3 id="1-线程的基本概念">1. 线程的基本概念
&lt;/h3>&lt;p>引入进程的目的是更好地使多道程序并发执行，&lt;strong>提高资源利用率和系统吞吐量。增加并发程度&lt;/strong>；而引入线程的目的是减小程序在并发执行时所付出的时空开销，&lt;strong>提高操作系统的并发性能&lt;/strong>。&lt;/p>
&lt;p>线程最直接的理解就是“轻量级进程”，它是一个&lt;strong>基本的 CPU 执行单元&lt;/strong>，也是&lt;strong>程序执行流的最小单元&lt;/strong>，其由&lt;strong>线程 ID、程序计数器、寄存器集合和堆栈组成&lt;/strong>。线程是&lt;strong>进程中的一个实体&lt;/strong>，是被&lt;strong>系统独立调度和分派的基本单位&lt;/strong>。线程不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属于一个进程的其它线程&lt;strong>共享所拥有的全部资源&lt;/strong>。一个线程&lt;strong>可以创建和撤销另一个线程&lt;/strong>，同一进程中的多个&lt;strong>线程之间可以并发执行&lt;/strong>。由于线程之间的相互制约，让线程在运行中呈现出&lt;strong>间断性&lt;/strong>。线程也有&lt;strong>就绪、阻塞和运行&lt;/strong>三种基本状态。&lt;/p>
&lt;p>引入线程后，进程的内涵就发生了改变，进程只作为除 CPU 外的系统资源的分配单元，线程则作为处理机的分配单元。由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要很小的系统资源。&lt;/p>
&lt;h3 id="2-线程与进程的比较">2. 线程与进程的比较
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>调度&lt;/strong>：在传统的操作系统中，拥有资源和独立调度的基本单位都是进程。在引入线程的操作系统中，&lt;strong>线程是独立调度的基本单位&lt;/strong>，进程则是拥有资源的基本单位。在同一进程中，线程的切换不会引起进程的切换；不同进程之间的线程切换则会引起进程的切换。&lt;/li>
&lt;li>&lt;strong>拥有资源&lt;/strong>：&lt;strong>进程是拥有资源的基本单位&lt;/strong>，线程可以访问隶属于进程的系统资源；&lt;/li>
&lt;li>&lt;strong>并发性&lt;/strong>：进程之间可以并发执行，多个线程之间也可以并发执行；&lt;/li>
&lt;li>&lt;strong>系统开销&lt;/strong>：操作系统在创建进程和撤销进程上的开销远大于创建线程和撤销线程上的；&lt;/li>
&lt;li>&lt;strong>地址空间和其它资源&lt;/strong>：进程的地址空间之间相互独立，同一进程的所有线程共享进程的资源；&lt;/li>
&lt;li>&lt;strong>通信方面&lt;/strong>：进程间通信（IPC）需要进程同步和互斥手段的辅助，以保证数据的一致性；而线程间可以直接读/写进程数据段来进行通信。&lt;/li>
&lt;/ul>
&lt;h3 id="3-线程的属性">3. 线程的属性
&lt;/h3>&lt;p>多线程操作系统将线程作为独立运行和调度的基本单位，此时进程不再是一个基本的可执行实体，但它仍具有与执行相关的状态。所谓进程处于“执行”状态，实际上是指该进程中的某县城正在执行。&lt;/p>
&lt;p>线程的主要属性如下：&lt;/p>
&lt;ul>
&lt;li>线程是一个轻型实体，不拥有系统资源。但每一个线程都有一个唯一的标识符和线程控制块，线程控制块记录了线程执行的寄存器和栈等线程状态；&lt;/li>
&lt;li>不同的线程可以执行相同的程序；&lt;/li>
&lt;li>同一进程中的各个线程共享该进程所拥有的资源；&lt;/li>
&lt;li>线程是处理机的独立调度单位，多个线程是可以并发执行的。单核 CPU 中各线程可以交替地占用 CPU，&lt;/li>
&lt;li>一个线程被创建后，便开始了它的生命周期，直至终止。&lt;/li>
&lt;/ul>
&lt;h3 id="4-线程的实现方式">4. 线程的实现方式
&lt;/h3>&lt;p>线程的实现方式可以分为两类：用户级线程（User-Level Thread，ULT）和内核级线程（Kernel-Level Thread，KLT），内核级线程又称内核支持的线程。&lt;/p>
&lt;p>在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计多线程程序。通常情况下，应用程序从单线程开始，在其运行的任何时刻都可以调用线程库创建新的线程。&lt;/p>
&lt;p>在内核级线程中，线程管理的所有工作都由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程编程的接口。内核进程为进程及内部的每个线程维护上下文信息，调度也在内核基于线程架构的基础上完成。&lt;/p>
&lt;p>有些系统中使用组合方式的多线程实现。线程创建完全在用户空间完成，线程的调度和同步也都在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于等于用户级线程）内核级线程上。&lt;/p>
&lt;h3 id="5-多线程模型">5. 多线程模型
&lt;/h3>&lt;p>有些系统同时支持用户线程和内核级线程，由此产生了不同的多线程模型（即实现用户级线程和内核级线程的连接方式）：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>多对一模型&lt;/strong>：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。此模式中，用户级线程对操作系统不可见（透明）；&lt;/li>
&lt;li>&lt;strong>一对一模型&lt;/strong>：将每个用户级线程映射到一个内核级线程；
&lt;ul>
&lt;li>优点：当一个线程被阻塞后允许另外一个线程继续执行，因此并发能力强；&lt;/li>
&lt;li>缺点：每创建一个用户级线程都需要创建一个内核级线程与其对应，这样创建线程的开销比较大，会影响到应用程序的性能。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>多对多模型&lt;/strong>：将 n 个用户级线程映射到 m 个内核级线程上，要求 m &amp;lt;= n。
&lt;ul>
&lt;li>特点：多对多模型是多对一模型和一对一模型的折中，即克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。同时又拥有两种模型各自的优点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>参考资料：王道考研——操作系统&lt;/p>
&lt;/blockquote></description></item><item><title>2.2 处理机调度</title><link>https://wlynxg.github.io/blog/p/2.2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/2.2-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="22-处理机调度">2.2 处理机调度
&lt;/h1>&lt;h2 id="思维导图">思维导图
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140258.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一调度的概念">一、调度的概念
&lt;/h2>&lt;h3 id="1-调度的基本概念">1. 调度的基本概念
&lt;/h3>&lt;p>在多道程序中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列按照一定的算法（公平、高效）选择一个进程并将处理机分配给它运行。&lt;/p>
&lt;h3 id="2-调度的层次">2. 调度的层次
&lt;/h3>&lt;p>一个作业从提交直到完成往往需要经历三级调度：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>作业调度（高级调度）&lt;/strong>：其主要任务是按照一定的原则，从外存上处于后备状态的作业中挑选一个（或多个）作业，给它们分配除处理机之外的必要资源，并建立相应的进程，以使它们获得竞争处理机资源的权力。对于每个作业只调入一次、调出一次；&lt;/li>
&lt;li>&lt;strong>中级调度（内存调度）&lt;/strong>：其作用是提高内存利用率和系统吞吐量。为此应将那些暂时不能运行的进程调度至外存等待，把此时的进程称为&lt;strong>挂起态&lt;/strong>。当它们已具有运行条件且内存又稍有空闲时，由中级调度来决定把外村上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待；&lt;/li>
&lt;li>&lt;strong>进程调度（低级调度）&lt;/strong>：其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。进程调度是&lt;strong>操作系统中最基本的一种调度&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="3-三级调度的关系">3. 三级调度的关系
&lt;/h3>&lt;ul>
&lt;li>作业调度为进程活动做准备，进程调度使进程正常活动起来，中级调度将暂时不能运行的进程挂起，中级调度处于作业调度和进程调度之间；&lt;/li>
&lt;li>作业调度次数少，中级调度次数略多，进程调度频率最高；&lt;/li>
&lt;li>进程调度是最基本的，不可或缺。&lt;/li>
&lt;/ul>
&lt;h2 id="二调度的时机切换与过程">二、调度的时机、切换与过程
&lt;/h2>&lt;p>进程调度和切换程序是操作系统内核程序。请求调度的事件发生后，才可能运行进程调度程序，调度了新的就绪进程后，才会进行进程间的切换。理论上这三种事情应当顺序发生，但在实际情况中，操作系统内核程序运行时，若某时发生了引起进程调度的因素，不一定会进行调度与切换。&lt;/p>
&lt;p>不能进行进程与切换的情况有以下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在处理中断的过程中&lt;/strong>：中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是操作系统的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源；&lt;/li>
&lt;li>&lt;strong>进程在操作系统内核程序临界区中&lt;/strong>：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其它进程运行；&lt;/li>
&lt;li>&lt;strong>其它需要完全屏蔽中断的原子操作过程中&lt;/strong>：在原子过程中，如加锁、解锁、中断线程保护、恢复等操作，此时连中断都需要屏蔽，更不应该进行进程调度和切换了。&lt;/li>
&lt;/ul>
&lt;p>若在上述过程发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到上述过程结束后才进行相应的调度与切换。&lt;/p>
&lt;p>应该进行进程调度与切换的情况如下：&lt;/p>
&lt;ul>
&lt;li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是非剥夺调度；&lt;/li>
&lt;li>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了剥夺方式的调度。&lt;/li>
&lt;/ul>
&lt;p>进程切换往往在调度完成后立刻发生，它要求保存原进程的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈装入新进程的现场信息、更新当前运行进程空间指针、重设 PC 寄存器等相关工作后，开始运行新的进程。&lt;/p>
&lt;h2 id="三进程调度方式">三、进程调度方式
&lt;/h2>&lt;p>所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，此时应该如何分配处理机。&lt;/p>
&lt;p>通常有以下两种进程调度方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>非剥夺调度方式（非抢占方式）&lt;/strong>：非剥夺调度方式是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程完成或进入阻塞状态时，才将处理机分配给更重要的进程。这种方式的优点是实现简单、系统开销小，适用于大部分批处理系统，但不适用于分时系统和绝大部分实时系统；&lt;/li>
&lt;li>&lt;strong>剥夺调度方式（抢占方式）&lt;/strong>：剥夺调度方式是指当一个进程正在处理机上执行时，若有某个优先级更高的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给优先级更高的进程。采用剥夺式的调度，对提高系统吞吐率和相应效率都有明显的好处，但“剥夺”不是一种任意的行为，必须遵守一定的原则，主要有优先权、短进程优先和时间片原则等。&lt;/li>
&lt;/ul>
&lt;h2 id="四进程调度的基本原则">四、进程调度的基本原则
&lt;/h2>&lt;p>不同的调度算法具有不同的特性，在选择调度算法时必须考虑算法的特性。&lt;/p>
&lt;p>算法的评价准则主要有以下几种：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CPU 利用率&lt;/strong>：CPU 是计算机中最重要和最昂贵的资源之一，好的调度算法应当尽可能是 CPU 在工作状态；&lt;/li>
&lt;li>&lt;strong>系统吞吐量&lt;/strong>：即单位时间内 CPU 完成作业的数量；&lt;/li>
&lt;li>&lt;strong>周转时间&lt;/strong>：指从作业提交到作业完成所经历的时间；
&lt;ul>
&lt;li>作业周转时间 = 作业完成时间 - 作业提交时间；&lt;/li>
&lt;li>平均周转时间 =（作业 1 周转时间 + 作业 2 周转时间 + &amp;hellip; + 作业 n 周转时间）/ n；&lt;/li>
&lt;li>带权周转时间 = 作业周转时间 / 作业实际运行时间；&lt;/li>
&lt;li>平均带权周转时间 = （作业 1 带权周转时间 + &amp;hellip; + 作业 n 带权周转时间）/ n。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>等待时间&lt;/strong>：指进程处于等待处理机状态的时间之和，等待使劲按越长用户满意度越低。衡量一个调度算法的优劣通常只需要简单地考察等待时间；&lt;/li>
&lt;li>&lt;strong>响应时间&lt;/strong>：指从用户提交请求到系统首次产生相应所用的时间。&lt;/li>
&lt;/ul>
&lt;h2 id="五典型的调度算法">五、典型的调度算法
&lt;/h2>&lt;h3 id="1-先来先服务fcfs算法">1. 先来先服务（FCFS）算法
&lt;/h3>&lt;p>FCFS 调度算法是一种最简单的调度算法，它既可以用于作业调度，又可以用于进程调度。&lt;/p>
&lt;p>在作业调度时，算法每次从后备作业队列中选择最先进入该队列的一个或几个任务，将它们调入内存，分配必要的资源，创建进程并放入就绪队列中。&lt;/p>
&lt;p>在进程调度时，FCFS 每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，直到进程完成任务或因为某种原因阻塞后才释放处理机。&lt;/p>
&lt;p>FCFS 属于不可剥夺算法。从表面上看，它对所有作业都是公平的，但若一个长作业优先到达队列，就会使后面的许多短作业等待很长时间。因此它不能用于分时系统和实时系统的主要调度策略。但它常被结合在其它调度策略中使用。&lt;/p>
&lt;p>FCFS 的特点是算法简单，但是效率较低；对长作业比较有利，对短作业不利；有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业。&lt;/p>
&lt;h3 id="2-短作业优先sjf算法">2. 短作业优先（SJF）算法
&lt;/h3>&lt;p>短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。&lt;/p>
&lt;p>短作业优先（SJF）调度算法从后备队列中选择一个或多个预估运行时间最短的作业，将它们调入内存运行；从就绪队列中选择一个预估时间最短的进程，将处理机资源分配给它，直到完成或发生某事件阻塞时才释放处理机。&lt;/p>
&lt;p>SJF 算法也存在不容忽视的缺点：&lt;/p>
&lt;ul>
&lt;li>该算法对长作业不利，长作业在队列中可能总是得不到资源；&lt;/li>
&lt;li>未考虑作业的紧迫程度；&lt;/li>
&lt;li>由于作业时间是根据用户提供信息设置的，该算法不一定能做到真正的短作业优先调度。&lt;/li>
&lt;/ul>
&lt;p>不过 SJF 算法的平均等待时间、平均周转时间最少。&lt;/p>
&lt;h3 id="3-优先级调度算法">3. 优先级调度算法
&lt;/h3>&lt;p>优先级调度算法又称为优先权调度算法，它既可以用于作业调度也可以用于进程调度。算法中的优先级用于描述作业运行的紧迫程序。&lt;/p>
&lt;p>根据新的更高优先级进程是否能够抢占正在执行的进程，可将该算法分为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>非剥夺式优先级调度算法&lt;/strong>：必须等到运行中的进程运行完毕或者阻塞时才能让更高优先级的进程使用处理机资源；&lt;/li>
&lt;li>&lt;strong>剥夺式优先级调度算法&lt;/strong>：正在运行的进程立即暂停，并将处理机资源让给更高优先级的进程。&lt;/li>
&lt;/ul>
&lt;p>根据进程创建后优先是否可以改变可以将算法分为：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>静态优先级&lt;/strong>：优先级是在创建进程是确定，在运行期间不可以更改；&lt;/li>
&lt;li>&lt;strong>动态优先级&lt;/strong>：优先级在创建进程是设定，可以根据情况动态的调整优先级。&lt;/li>
&lt;/ul>
&lt;p>进程优先级的设置一般参考以下准则：&lt;/p>
&lt;ul>
&lt;li>系统进程 &amp;gt; 用户进程；&lt;/li>
&lt;li>交互进程 &amp;gt; 非交互进程（前台进程 &amp;gt; 后台进程）；&lt;/li>
&lt;li>I/O 型进程 &amp;gt; 计算型进程。&lt;/li>
&lt;/ul>
&lt;h3 id="4-高响应比优先调度算法">4. 高响应比优先调度算法
&lt;/h3>$$
响应比R_p = {等待时间 + 要求服务时间\over 要求服务时间}
$$&lt;p>
根据公式可知：&lt;/p>
&lt;ul>
&lt;li>作业等待时间相同，要求服务时间越短，响应比越高，越有利于短作业；&lt;/li>
&lt;li>要求服务时间相同时，作业的响应时间由其等待时间决定，等待时间越长，其响应比越高，因而它实现的时先来先服务；&lt;/li>
&lt;li>对于长作业，作业的响应比可以随等待时间的增加而提高，等待时间足够长时，其响应比可得到提升，从而可以获得处理机，因此兼顾了长作业。&lt;/li>
&lt;/ul>
&lt;h3 id="5-时间片轮转调度算法">5. 时间片轮转调度算法
&lt;/h3>&lt;p>时间片轮转调度算法主要适用于分时系统。&lt;/p>
&lt;p>在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中的第一个执行，但仅能运行一个时间片。若一个时间片内进程完成作业，则退出操作系统；若未完成，则也必须释放处理机资源，然后进入就绪队列的末尾重新排队，等待再次运行。&lt;/p>
&lt;p>在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。时间片过长则可能会变成 FCFS 调度算法；若时间片过短系统又可能频繁切换，使处理机的开销增大。&lt;/p>
&lt;p>时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。&lt;/p>
&lt;h3 id="6-多级反馈队列调度算法融合了前几种算法的优点">6. 多级反馈队列调度算法（融合了前几种算法的优点）
&lt;/h3>&lt;p>多继反馈队列算法是时间片轮转调度算法和优先级调度算法的综合与发展，通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。&lt;/p>
&lt;p>多级反馈调度算法的思想如下：&lt;/p>
&lt;ul>
&lt;li>设置多个就绪队列，并为各个队列赋予不同的优先级，第一级队列的优先级最高，第二级次之，其余队列优先级逐步降低；&lt;/li>
&lt;li>赋予各个队列中进程执行时间片的大小各不相同。在优先级越高的队列中，每个进程的运行时间片越小；&lt;/li>
&lt;li>当一个新进程进入内存后，首先放入第一级队列末尾，按 FCFS 原则等待调度。当轮到该进程执行时，若能在该时间片完成，则可准备撤离系统；若不能完成，则将该进程转入第二级队列末尾，按照相同的规律一直进行下去。当降到第 n 级队列中便采用时间片轮转的方式进行；&lt;/li>
&lt;li>仅当第一级队列为空时，调度程序才调度第二级队列的进程，仅当第 1 ~ （i - 1）级队列均为空时，才调度第 i 级队列的进程。若处理机正在处理第 i 级的进程，此时有新进程进入更高优先级的队列，则此时进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回第 i 级队列的末尾，把处理机分配给新到的更改优先级进程使用。&lt;/li>
&lt;/ul>
&lt;p>多级反馈队列的优势：&lt;/p>
&lt;ul>
&lt;li>终端型作业用户：短作业优先；&lt;/li>
&lt;li>短批量处理作业用户：周转时间短；&lt;/li>
&lt;li>长批量处理作业用户：经过前面几个队列作业部分执行，不会长期得不到处理。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>参考资料：王道考研——操作系统&lt;/p>
&lt;/blockquote></description></item><item><title>2.3 进程同步</title><link>https://wlynxg.github.io/blog/p/2.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/2.3-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</guid><description>&lt;h1 id="23-进程同步">2.3 进程同步
&lt;/h1>&lt;h2 id="思维导图">思维导图
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140322.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一进程同步的基本概念">一、进程同步的基本概念
&lt;/h2>&lt;p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的制约关系。为了协调进程之间的相互制约的关系，引入进程同步的概念。&lt;/p>
&lt;h3 id="1-临界资源">1. 临界资源
&lt;/h3>&lt;p>多个进程可以共享的各种资源，但是有的资源只能&lt;strong>同时为一个进程服务&lt;/strong>，这样的资源就被称为临界资源。&lt;/p>
&lt;p>对于临界资源的访问必须互斥地进行。在每个进程中，访问临界资源的代码称为&lt;strong>临界区&lt;/strong>。为了确保临界资源的正确使用，可以将临界资源的访问分为四个过程：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>进入区&lt;/strong>：为了进入临界区使用临界资源，在进入区要检查能否进入临界区。若能进入临界区，则应设置正在访问临界区的标志，以阻止其它进程同时进入临界区；&lt;/li>
&lt;li>&lt;strong>临界区&lt;/strong>：进程中访问临界资源的那段代码，又称临界段；&lt;/li>
&lt;li>&lt;strong>退出区&lt;/strong>：将正在访问临界区的标志清除；&lt;/li>
&lt;li>&lt;strong>剩余区&lt;/strong>：代码中的其余部分。&lt;/li>
&lt;/ul>
&lt;h3 id="2-同步">2. 同步
&lt;/h3>&lt;p>同步亦称&lt;strong>直接制约关系&lt;/strong>。是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递消息所产生的制约关系。进程间的直接制约关系源于它们之间的相互合作。&lt;/p>
&lt;p>例如输入进程 A 通过单缓冲向进程 B 提供数据。当该缓冲区为空时，进程 B 不能获得所需要的数据而阻塞，当进程 A 将数据输入缓冲区时，进程 B 被唤醒；当缓冲区为满时，进程 A 被阻塞，当 B 从缓冲区取走数据后，进程 A 被唤醒。&lt;/p>
&lt;h3 id="3-互斥">3. 互斥
&lt;/h3>&lt;p>互斥也称&lt;strong>间接制约关系&lt;/strong>。当一个进程进入临界资源区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一个进程才允许去访问此资源。&lt;/p>
&lt;p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>空闲让进&lt;/strong>：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；&lt;/li>
&lt;li>&lt;strong>忙则等待&lt;/strong>：当已有进程进入临界区时，其它试图进入临界区的进程必须等待；&lt;/li>
&lt;li>&lt;strong>有限等待&lt;/strong>：对请求访问的资源，应保证能在有限时间内进入临界区；&lt;/li>
&lt;li>&lt;strong>让权等待&lt;/strong>：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。&lt;/li>
&lt;/ul>
&lt;h2 id="二实现临界区互斥的基本方法">二、实现临界区互斥的基本方法
&lt;/h2>&lt;h3 id="1-软件实现方法">1. 软件实现方法
&lt;/h3>&lt;p>在进入区设置一些标志来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。&lt;/p>
&lt;h4 id="算法一单标志法">算法一：单标志法
&lt;/h4>&lt;p>该算法设置一个公用整型变量 &lt;code>turn&lt;/code>，用于指示被允许进入临界区的进程编号。若 &lt;code>turn = 0&lt;/code>，则允许 P0 进程进入临界区。那么谁来改变 &lt;code>turn&lt;/code> 的值？如果是公共区域控制&lt;code>turn&lt;/code>这个变量，那么 P0 不想进的时候，即使是 &lt;code>turn = 0&lt;/code> ,对于进程 P0 也是没有价值的。公共区域无法预测谁想要，所以这个控制权还是分权给进程来管理比较好一些。&lt;/p>
&lt;p>Pi想进入时检测 &lt;code>turn&lt;/code> 值是否是自己的 &lt;code>turn&lt;/code>，如果不是，就需要等待，该算法可确保每次只允许一个进程进入临界区。两个进程必须交替进入临界区，一个进程进入临界区，使用完成后将 &lt;code>turn&lt;/code>的值设置为另外一个进程。若某个进程不再进入临界区，则另一个进程也将无法进入临界区（违背“空闲让进”）。若 P0 顺利进入临界区并从临界区离开，则此时临界区是空闲的，但 P1 并没有进入临界区的打算，&lt;code>turn = 1&lt;/code>一直成立，P0 就无法再次进入临界区（一直被 while 死循环困住）。&lt;/p>
&lt;p>&lt;strong>算法描述：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">P0&lt;/span> &lt;span class="err">进程：&lt;/span> &lt;span class="n">P1&lt;/span> &lt;span class="err">进程：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">turn&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">turn&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">turn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">turn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// exit section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="算法二双标志法先检查">算法二：双标志法先检查
&lt;/h4>&lt;p>该算法的基本思想是在每个进程访问临界区之前，先检查临界区资源是否正在访问。若正在被访问，则该进程需等待；否则进程进入自己的临界区。为此设置一个数据 &lt;code>flag[i]&lt;/code>， 如第 i 个元素为 &lt;code>FALSE&lt;/code>，则表示 Pi 进程未进入临界区；值为 &lt;code>TRUE&lt;/code>，表示 Pi 进程进入临界区。&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>：不要交替进入，可连续使用；&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>：按 ①②③④ 执行时，Pi 和 Pj 会同时进入临界区（违背“忙则等待”）。这里问题出在检查和修改操作不能一次进行。&lt;/p>
&lt;p>&lt;strong>算法描述：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Pi&lt;/span> &lt;span class="err">进程：&lt;/span> &lt;span class="n">Pj&lt;/span> &lt;span class="err">进程：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="err">①&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="err">②&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TRUE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="err">③&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TRUE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="err">④&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FALSE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FALSE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// exit section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="算法三双标志法后检查">算法三：双标志法后检查
&lt;/h4>&lt;p>该算法先将自己的标志设置为 &lt;code>TRUE&lt;/code>，再检测对方的状态标志，若对方标志为 &lt;code>TRUE&lt;/code> 则进入等待；否则进入临界区。&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>：两个进程同时想进入等待区时，它们分别将自己的标志 &lt;code>flag&lt;/code> 设置为 &lt;code>TRUE&lt;/code>，然后再进行检测时就会发生“饥饿”现象，双方都无法进入临界区。&lt;/p>
&lt;p>&lt;strong>算法描述：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Pi&lt;/span> &lt;span class="err">进程：&lt;/span> &lt;span class="n">Pj&lt;/span> &lt;span class="err">进程：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TRUE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TRUE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">FLASE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">flag&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FLASE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// exit section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="算法四petersons-algorithm">算法四：Peterson’s Algorithm
&lt;/h4>&lt;p>为了防止两个进程为进入临界区而无限期等待，又设置了变量 &lt;code>turn&lt;/code>，每个进程在先设置自己的标志后再设置 &lt;code>turn&lt;/code> 标志。这是，再同时检测另一个进程状态标志和不允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。&lt;/p>
&lt;p>&lt;strong>优点&lt;/strong>：利用 &lt;code>flag&lt;/code> 解决临界资源互斥访问，利用 &lt;code>turn&lt;/code> 解决“饥饿”现象；&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>：未遵循“让权等待”。&lt;/p>
&lt;p>&lt;strong>算法描述：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">Pi&lt;/span> &lt;span class="err">进程：&lt;/span> &lt;span class="n">Pj&lt;/span> &lt;span class="err">进程：&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TURE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">turn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">TRUE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">turn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">turn&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="k">while&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">turn&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// entry section
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">FLASE&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">flag&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">FLASE&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2-硬件实现方法">2. 硬件实现方法
&lt;/h3>&lt;p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字中的内容进行交换等。通过硬件支持实现临界段问题的方法称为&lt;strong>低级方法或元方法&lt;/strong>。&lt;/p>
&lt;h4 id="1中断屏蔽方法">（1）中断屏蔽方法
&lt;/h4>&lt;p>当一个进程正在使用处理机执行它的临界区代码时，防止其他进程进入临界区进行访问的最简方法就是禁止一切中断发生，或称为屏蔽中断、关闭中断。其原理为 CPU 在发生中断时切换进程，因此关闭中断就能让临界区代码顺利执行完成。其典型模式为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">关中断；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">临界区代码；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">开中断；&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此种方法限制了处理机交替执行程序的能力，因此执行效率会明显降低。对内核而言，在它执行更新变量或列表的几条指令期间，关中断是很方便的。但是将关中断的权力移交给用户是很不明智的，若进程关中断后不再打开，很可能会让系统终止。&lt;/p>
&lt;h4 id="2硬件指令方法">（2）硬件指令方法
&lt;/h4>&lt;blockquote>
&lt;p>&lt;strong>TestAndSet 指令&lt;/strong>：该指令为原子操作，执行该代码时不允许被中断。其功能为读出指定标志后把该标志设置为真。&lt;/p>
&lt;/blockquote>
&lt;p>指令的功能描述如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c++" data-lang="c++">&lt;span class="line">&lt;span class="cl">&lt;span class="n">boolean&lt;/span> &lt;span class="nf">TestAndSet&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">boolean&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">boolean&lt;/span> &lt;span class="n">old&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">old&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">old&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以为每个临界资源设置一个共享布尔型变量 &lt;code>lock&lt;/code>，表示资源的两种状态：&lt;code>true&lt;/code>表示正被占用，初始值为&lt;code>false&lt;/code>。在进程访问临界资源之前，利用 &lt;code>TestAndSet&lt;/code>检查和修改标志 &lt;code>lock&lt;/code>；若有进程在临界区，则反复检查，直到进程退出。利用该指令实现进程互斥的算法描述如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span> &lt;span class="nf">TestAndSet&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>Swap 指令：该指令的功能是交换两个字节的内容。&lt;/p>
&lt;/blockquote>
&lt;p>其功能描述如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">Swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">boolean&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">boolean&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">boolean&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">*&lt;/span>&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>应为每个临界资源设置一个共享布尔型变量 &lt;code>lock&lt;/code>，初值为 &lt;code>false&lt;/code>；在每个进程中再设置一个局部布尔型变量 &lt;code>key&lt;/code>，用于与 &lt;code>lock&lt;/code>交换信息。在进入临界区前，先利用 &lt;code>Swap&lt;/code>指令交换 &lt;code>lock&lt;/code> 与 &lt;code>key&lt;/code> 的内容，再检查 key 的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。利用 &lt;code>Swap&lt;/code> 指令实现进程互斥的算法描述如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">key&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">true&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">key&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">Swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">key&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">critical&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">lock&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">false&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">remainder&lt;/span> &lt;span class="n">section&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>优点&lt;/strong>：适用于任意数目的进程，并且不管是单处理机还是多处理机都适用；简单、容易验证其正确性。可以支持进程内有多个临界区，只需要为每个临界区设立一个布尔型变量。&lt;/p>
&lt;p>&lt;strong>缺点&lt;/strong>：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待队列中随机选择一个进入临界区，有的进程可能一直选不上，从而导致“饥饿”现象。&lt;/p>
&lt;h2 id="三信号量">三、信号量
&lt;/h2>&lt;blockquote>
&lt;p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语&lt;code>wait(S)&lt;/code>和&lt;code>signal(S)&lt;/code>访问，也可记作“P操作”和“V操作”。&lt;/p>
&lt;/blockquote>
&lt;p>原语是指完成某种功能且不被分割、不被中断执行的操作序列。原语之所以不能被中断执行，是因为原语对变量的操作若被打断，可能会去运行另一个对同一变量的操作过程，从而出现临界问题。&lt;/p>
&lt;h3 id="1-整型信号量">1. 整型信号量
&lt;/h3>&lt;p>整型信号量被定义为一个用于表示资源数目的整型量 &lt;code>S&lt;/code>，&lt;code>wait&lt;/code> 和 &lt;code>signal&lt;/code> 操作可描述为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="nf">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">S&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">S&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">signal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">S&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">S&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>wait&lt;/code> 操作中，只要信号量 &lt;code>S &amp;lt;= 0&lt;/code>，就会不断测试。因此该机制未遵循“让权等待”，而是使进程处于“忙等”的状态。&lt;/p>
&lt;h3 id="2-记录型信号量">2. 记录型信号量
&lt;/h3>&lt;p>记录型信号量是不存在“忙等”现象的进程同步机制。除需要一个用于代表资源数目的整型变量 &lt;code>value&lt;/code> 外，再增加一个进程链表 &lt;code>L&lt;/code>，用于链接所有等待资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">struct&lt;/span> &lt;span class="n">process&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span> &lt;span class="n">semaphore&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相应的 &lt;code>wait&lt;/code> 和 &lt;code>signal&lt;/code> 的操作如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">wait&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">S&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">add&lt;/span> &lt;span class="n">this&lt;/span> &lt;span class="n">process&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">blcok&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>wait&lt;/code>操作，&lt;code>S.value--&lt;/code>表示进程请求一个该类资源，当&lt;code>S.value &amp;lt; 0&lt;/code>时，表示该类资源已经分配完毕，因此进程应调用&lt;code>block&lt;/code>原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列S.L，可见该机制遵循了“让权等待”。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">void&lt;/span> &lt;span class="nf">signal&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">S&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">value&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">remove&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="n">process&lt;/span> &lt;span class="n">P&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">S&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">wakeup&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">P&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>signal&lt;/code>操作，表示进程释放一个资源，使进程中可分配的该类资源数加一，故有&lt;code>S.value++&lt;/code>。若加一后&lt;code>S.value &amp;lt;= 0&lt;/code>，则表示&lt;code>S.L&lt;/code>中仍有等待该资源的进程被阻塞，故还应该调用&lt;code>wakeup&lt;/code>原语，将&lt;code>S.L&lt;/code>中的第一个等待进程唤醒。&lt;/p>
&lt;h3 id="3-利用信号量实现同步">3. 利用信号量实现同步
&lt;/h3>&lt;p>信号量机制能用于解决进程间的各种同步问题。设 S 为实现进程 P1、P2 同步的公共信号量，初始值为 0。进程 P2 中的语句 y 要使用进程 P1 中语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。&lt;/p>
&lt;p>其实现同步的算法如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">S&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 初始化信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">P1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 语句 x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 告诉进程 P2，语句 x 已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">P2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查语句 x 是否完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 语句 y
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>若 P2 先执行到&lt;code>P(S)&lt;/code>时，&lt;code>S = 0&lt;/code>，执行 P 操作就会阻塞进程，并放入阻塞队列；当 P1 中 x 执行完后，执行 V 操作，把 P2 从阻塞队列放回就绪队列，当 P2 得到处理机时，就可以继续运行。&lt;/p>
&lt;h3 id="4-利用信号量实现进程互斥">4. 利用信号量实现进程互斥
&lt;/h3>&lt;p>信号量机制也能很方便的解决进程互斥的问题。设 S 为实现进程 P1、P2 互斥的信号量，由于每次只允许一个进程进而临界区，所以 S 的初值为 1（即可用资源数为 1）。只需要把临界区置于 P(S) 和 V(S) 之间，即可实现两个进程对临界资源的互斥访问。其算法如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">S&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 初始化信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">P1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 准备开始访问临界资源，加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">进程&lt;/span> &lt;span class="n">P1&lt;/span> &lt;span class="err">的临界区&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 访问结束，解锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">P2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 准备开始访问临界资源，加锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="err">进程&lt;/span> &lt;span class="n">P2&lt;/span> &lt;span class="err">的临界区&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">S&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 访问结束，解锁
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当没有进程在临界区时，任意一个进程要进入临界区，都要执行 P 操作，把 S 的值减为 0，然后进入临界区；当有进程存在于临界区时，S 的值为 0，再有进程要进入临界区，执行 P 操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。&lt;/p>
&lt;p>在同步问题中，若某个行为要用到某种资源，则这个行为前面执行 P 操作；若某个行为会提供某种资源，则在该行为后面执行 V 操作。在互斥问题中，P、V 操作要紧夹使用互斥资源的行为，不能有冗余代码。&lt;/p>
&lt;h3 id="5-利用信号量实现前驱关系">5. 利用信号量实现前驱关系
&lt;/h3>&lt;p>信号量也可用来描述程序之间或语句之间的前驱关系。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-215019.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;p>在上面的前驱图中，S1、S2&amp;hellip;S6是最简单的程序段（只有一条语句）。为了使程序段能正确执行，需要设置若干初始值为 &amp;ldquo;0&amp;rdquo; 的信号量。&lt;/p>
&lt;p>实现算法如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">a1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">b1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">b2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">c3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 初始化信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nf">S1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">...;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// S1 已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">S2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查 S1 是否完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// S2 已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">S3&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查 S1 是否已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// S3 已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">S4&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查 S2 是否已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// S4 已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">S5&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">b2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查 S2 是否已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">...;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// S5 已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">S6&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c1&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c2&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">c3&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 检查S3、S4、S5 是否已经完成
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="6-分析进程同步和互斥问题的方法步骤">6. 分析进程同步和互斥问题的方法步骤
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>关系分析&lt;/strong>：找出问题中的进程数，并分析它们之间的同步和互斥的关系；&lt;/li>
&lt;li>&lt;strong>整理思路&lt;/strong>：找出解决问题的关键点，根据进程的操作流程确定 P、V 的大致顺序；&lt;/li>
&lt;li>&lt;strong>设置信号量&lt;/strong>：根据需要的信号量，确定初值。&lt;/li>
&lt;/ul>
&lt;h2 id="四管程">四、管程
&lt;/h2>&lt;h3 id="1-管程的定义">1. 管程的定义
&lt;/h3>&lt;blockquote>
&lt;p>系统中的各种硬件资源和软件资源均可以用数据结构进行抽象的描述其资源特性。管程是由一组数据及定义在这对数据之上的操作组成的软件模块，这组操作能初始化并改变管程中的数据和同步进程。&lt;/p>
&lt;/blockquote>
&lt;h3 id="2-管程的组成">2. 管程的组成
&lt;/h3>&lt;ul>
&lt;li>局部于管程的共享变量；&lt;/li>
&lt;li>对数据结构进行操作的一组过程；&lt;/li>
&lt;li>对局部于管程的数据进行初始化的语句。&lt;/li>
&lt;/ul>
&lt;h3 id="3-管程的基本特性">3. 管程的基本特性
&lt;/h3>&lt;ul>
&lt;li>局部于管程的数据只能被局部于管程内的过程访问；&lt;/li>
&lt;li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；&lt;/li>
&lt;li>每次仅允许一个进程在管程内执行某个内部过程。&lt;/li>
&lt;/ul>
&lt;h3 id="4-管程的属性">4. 管程的属性
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>共享性&lt;/strong>：管程可被系统范围内的进程互斥访问，属于共享资源；&lt;/li>
&lt;li>&lt;strong>安全性&lt;/strong>：管程的局部变量只能由管程的过程访问，不允许进程或其它管程直接访问，管程也不能访问非局部于它的变量；&lt;/li>
&lt;li>&lt;strong>互斥性&lt;/strong>：多个进程对管程的访问是互斥的。任一时刻，管程中只能有一个活跃进程；&lt;/li>
&lt;li>&lt;strong>封装性&lt;/strong>：管程内的数据结构是私有的，只能在管程内使用，管程内的过程也只能使用管程内的数据结构。进程通过调用管程的过程使用临界资源。&lt;/li>
&lt;/ul>
&lt;h2 id="五经典同步问题">五、经典同步问题
&lt;/h2>&lt;h3 id="1-生产者-消费者问题">1. 生产者-消费者问题
&lt;/h3>&lt;p>&lt;strong>问题描述&lt;/strong>：一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区。只有缓冲区没满时生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不为空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，只允许一个消费者从中取出消息。&lt;/p>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>关系分析&lt;/strong>：生产者和消费者对缓冲区访问是既是互斥关系又是同步关系；&lt;/li>
&lt;li>&lt;strong>整理思路&lt;/strong>：需要解决互斥和同步 PV 操作的位置；&lt;/li>
&lt;li>&lt;strong>信号量设置&lt;/strong>：信号量 mutex 作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量为 1；信号量 full 用于记录当前缓冲池中的“满”缓冲区数，初值为 0；信号量 empty 用于记录当前缓冲池中“空”缓冲区数，初值为 n。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>算法描述&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">mutex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">empty&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">full&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 初始化信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">producer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">produce&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="n">in&lt;/span> &lt;span class="n">nextp&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 生产数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// （要用什么 P 什么）获取空缓冲单元
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// （互斥夹紧）进入临界区
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">add&lt;/span> &lt;span class="n">nextp&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// （行为）将数据放入缓冲区
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// （互斥夹紧）离开临界区
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">full&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// （提供什么 V 什么）满缓冲区加一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">consumer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">full&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 获取满缓冲区单元
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 进入临界区
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">remove&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">item&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">buffer&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 从缓冲区取出数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 离开临界区，释放互斥信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">empty&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 空缓冲区数加一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">consume&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 消费数据
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>下面再来看一个较为复杂的生产者-消费者问题：&lt;/p>
&lt;p>&lt;strong>问题描述&lt;/strong>：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专门向盘子中放苹果，妈妈专门向进程中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可以向盘子中放水果，仅当盘子中有对应的水果时，儿子女儿才能从盘子中取出水果。&lt;/p>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>关系分析&lt;/strong>：爸爸和妈妈是互斥关系，爸爸和女儿、妈妈和儿子是同步关系，儿子和女儿没有关系。女儿或儿子拿走水果后才能释放盘子；&lt;/li>
&lt;li>&lt;strong>整理思路&lt;/strong>：四个进程可以抽象为两个生产者和两个消费者被连接到大小为 1 的缓冲区上；&lt;/li>
&lt;li>&lt;strong>信号量设置&lt;/strong>：信号量 plate 为互斥信号量，初值为 1；信号量 apple 表示盘子中是否有水果，初值为 0；信号量 orange 表示盘子中是否有橘子，初值为 0。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>算法描述&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">plate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">apple&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">orange&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 初始化信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">dad&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">prepare&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">apple&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">plate&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥向盘中取、放水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">put&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">apple&lt;/span> &lt;span class="n">on&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">plate&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 向盘中放水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">apple&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 允许取苹果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">mom&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">prepare&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">orange&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">plate&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥向盘中取、放水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">put&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">orange&lt;/span> &lt;span class="n">on&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">plate&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 向盘中放水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">orange&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 允许取橘子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">son&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">orange&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥向盘中取水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">take&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">orange&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">plate&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 取水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">plate&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 允许向盘子中取、放水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">eat&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">orange&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">daughter&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">apple&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥向盘中取水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">take&lt;/span> &lt;span class="n">an&lt;/span> &lt;span class="n">apple&lt;/span> &lt;span class="n">from&lt;/span> &lt;span class="n">plate&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 取水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">plate&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 允许向盘子中取、放水果
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">eat&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="n">apple&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="2-读者-写者问题">2. 读者-写者问题
&lt;/h3>&lt;p>&lt;strong>问题描述&lt;/strong>：有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问数据时不会产生副作用。但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。&lt;/p>
&lt;p>因此要求：&lt;/p>
&lt;ul>
&lt;li>允许多个读者可以同时对文件执行读操作；&lt;/li>
&lt;li>只允许一个写者往文件中写信息；&lt;/li>
&lt;li>任意写者在完成操作前都不允许其他读者或写者工作；&lt;/li>
&lt;li>写者操作前应该让已有的读者和写者退出。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>关系分析&lt;/strong>：读者和写者是互斥的，写者和写者也是互斥的，读者和读者之间不存在互斥现象。&lt;/li>
&lt;li>&lt;strong>整理思路&lt;/strong>：写者和任何进程互斥，用 PV 操作即可。写者必须在实现与写者互斥的同时，实现与其他读者的同步。这里需要使用一个计数器，用来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，读者会一直占用文件，当没有读者时，写者才可以写文件。同时不同读者对计数器的访问也是互斥的。&lt;/li>
&lt;li>&lt;strong>信号量设置&lt;/strong>：设置信号量 count 为计数器，用于记录当前读者的数量，初值为 0；设置 mutex 为互斥信号量，用于保护更新 count 变量时的互斥；设置互斥信号量 rw，用于保证读者和写者的互斥访问。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>算法描述&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 用于记录当前的读者数量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">mutex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rw&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 用于保护更新 count 变量时的互斥和读者写者互斥地访问
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">writer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥访问共享文件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">writing&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 写入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放共享文件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">reader&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥访问 count 变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 当第一个读进程读共享文件时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 阻止写进程写
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 读者计数器加一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放互斥变量 count
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">reading&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 读取
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥访问 count 变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 读者计数器减一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 当最后一个读进程读完共享文件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 允许写进程
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放互斥变量 count
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在上面地算法中，读进程是优先的。当存在读进程时，写操作将被延迟，且只要有一个读进程活跃，随后而来的读进程都将被允许文件。这样的方式会导致写进程可能长时间等待，且存在写进程“饿死”情况。&lt;/p>
&lt;p>若希望写进程优先，即有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完成，立即让写进程执行，只有在无写进程执行的情况下允许读进程再次运行。为此需要增加一个信号量并在上面程序的&lt;code>write()&lt;/code> 和 &lt;code>reader()&lt;/code>函数中各增加一个 PV 操作，就可以得到写进程优先的解决程序。&lt;/p>
&lt;p>&lt;strong>算法实现&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 计数器初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">mutex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">rw&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">w&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 信号量初始化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">writer&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 在无写进程请求时进入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥访问共享文化
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">writing&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 写入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放共享文件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 恢复共享文件的访问
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">reader&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 在无写进程请求时进入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥访问 count 变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 在第一个读进程共享文件时
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 阻止写进程写
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 读者计数器加一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放互斥变量 count
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">w&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 恢复对共享文件的访问
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">reading&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 读取
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 互斥访问 count 变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="o">--&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 读者计数器减一
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">count&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// 当最后一个读进程读完共享文件
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">rw&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 运行写进程写
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放互斥变量 count
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>读者-写者问题有一个关键的特征：有一个互斥访问的 count 计数器。我们解决其他互斥问题时也可以尝试以下 count 计数器互斥。&lt;/p>
&lt;h3 id="3-哲学家进餐问题">3. 哲学家进餐问题
&lt;/h3>&lt;p>&lt;strong>问题描述&lt;/strong>：一张圆桌上坐着五名哲学家，每两名哲学家之间的桌子上摆一根筷子，两根筷子中间是一碗米饭。哲学家在思考时，并不影响他人；当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。若筷子已在他人手上，则需要等待。饥饿地哲学家只有同时拿到两根筷子才可以开始进餐，进餐完毕后继续思考。&lt;/p>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>关系分析&lt;/strong>：五名哲学家与左右邻居是互斥的关系。&lt;/li>
&lt;li>&lt;strong>整理思路&lt;/strong>：本问题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁现象。解决办法有两个：一是让他们同时拿到两根筷子；二是对每个哲学家的动作制定规则。&lt;/li>
&lt;li>&lt;strong>信号量设置&lt;/strong>：定义互斥信号量数组 &lt;code>chopstick[5] = {1, 1, 1, 1, 1}&lt;/code>，用于五个筷子的互斥访问。哲学家按顺序标号 0~4，哲学家 i 左边筷子的编号为 i，哲学家右边筷子的编号为&lt;code>(i + 1) % 5&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>算法实现&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">chopstick&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">};&lt;/span> &lt;span class="c1">// 定义信号量数组 chopstick[5]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">Pi&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 取左边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 取右边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">eat&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 进餐
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 放回左边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 放回右边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">think&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 思考
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该算法存在以下问题：当五名哲学家都想要进餐并分别拿起左边筷子时（都恰好执行完&lt;code>wait(chopstick[i]);&lt;/code>）筷子已经被拿完，等到他们再想拿右边筷子时就全部阻塞，因此出现了死锁。&lt;/p>
&lt;p>为了防止死锁的发生，可对哲学家进餐施加一些限制条件：当左右两边筷子都可以用时，才允许他抓取筷子。&lt;/p>
&lt;p>&lt;strong>算法描述&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="n">semaphore&lt;/span> &lt;span class="n">chopstick&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">};&lt;/span> &lt;span class="c1">// 定义信号量数组 chopstick[5]
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">mutex&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 设置取筷子信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nf">Pi&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">do&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 在取筷子前获得互斥量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 取左边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 取右边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">mutex&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="c1">// 释放取筷子信号量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">eat&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 进餐
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 放回左边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">chopstick&lt;/span>&lt;span class="p">[(&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">]);&lt;/span> &lt;span class="c1">// 放回右边筷子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">think&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 思考
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="4-吸烟者问题">4. 吸烟者问题
&lt;/h3>&lt;p>&lt;strong>问题描述&lt;/strong>：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟，抽烟者必须要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷起一根烟并抽掉它，并给供应者一个信号已完成，此时供应者就会将另外两种材料放到桌上，如此重复。&lt;/p>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>关系分析&lt;/strong>：供应者与三个抽烟者分别是同步关系。由于供应者同时只能满足一个抽烟者，因此三个抽烟者对抽烟这个动作互斥。&lt;/li>
&lt;li>&lt;strong>整理思路&lt;/strong>：供应者作为生产者向三个抽烟者提供材料。&lt;/li>
&lt;li>&lt;strong>信号量设置&lt;/strong>：信号量 offer1、offer2、offer3 分别表示三个吸烟者需要的资源组合。信号量 finish 用于互斥进行抽烟动作。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>算法描述&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">random&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">// 存储随机数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">semaphore&lt;/span> &lt;span class="n">offer1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">offer2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">offer3&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">finsh&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">process&lt;/span> &lt;span class="nf">P&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 供应者
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">random&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="err">任意整数&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">random&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">random&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">offer1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">random&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">offer2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">else&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">offer3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">任意两种材料放在桌子上&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">finish&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">process&lt;/span> &lt;span class="nf">C1&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 抽烟者1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">offer1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">抽烟&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">finish&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">process&lt;/span> &lt;span class="nf">C2&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 抽烟者2
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">offer2&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">抽烟&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">finish&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">process&lt;/span> &lt;span class="nf">C3&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 抽烟者3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">P&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">offer3&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="err">抽烟&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nf">V&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">finish&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div></description></item><item><title>2.4 死锁</title><link>https://wlynxg.github.io/blog/p/2.4-%E6%AD%BB%E9%94%81/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/2.4-%E6%AD%BB%E9%94%81/</guid><description>&lt;h1 id="24-死锁">2.4 死锁
&lt;/h1>&lt;h2 id="思维导图">思维导图
&lt;/h2>&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140335.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="一死锁的概念">一、死锁的概念
&lt;/h2>&lt;h3 id="1-死锁的定义">1. 死锁的定义
&lt;/h3>&lt;blockquote>
&lt;p>在多道程序中，由于多个进程的并发执行，改善了系统资源的利用率，并提高了系统的处理能力。然而多个进程的并发执行也带来了新的问题——死锁。所谓死锁，是指多个进程因竞争关系而造成的一种僵局（相互等待），若无外力作用，这些进程都将无法向前推进。&lt;/p>
&lt;/blockquote>
&lt;h3 id="2-死锁产生的原因">2. 死锁产生的原因
&lt;/h3>&lt;h4 id="1系统资源的竞争">（1）系统资源的竞争
&lt;/h4>&lt;p>通常系统中拥有不可剥夺资源，其数量不足以满足多个进程运行的必须，使得进程在运行过程中，会因为争夺资源陷入僵局。只有对不可剥夺资源的竞争才会产生死锁，对可剥夺资源的竞争是不会引起死锁的。&lt;/p>
&lt;h4 id="2进程推进顺序非法">（2）进程推进顺序非法
&lt;/h4>&lt;p>进程在运行过程中，请求和释放资源的顺序不当，同样会导致死锁。信号量使用不当也会造成死锁，进程间彼此互相等待对方发来的消息，也会使得这些进程间无法继续向前推进。&lt;/p>
&lt;h4 id="3死锁产生的必要条件">（3）死锁产生的必要条件
&lt;/h4>&lt;p>死锁的产生必须&lt;strong>同时满足&lt;/strong>以下四个条件：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>互斥条件&lt;/strong>：进程要求对所分配的资源进行排他性控制，即在一段时间内资源仅为一个进程所有；&lt;/li>
&lt;li>&lt;strong>不剥夺条件&lt;/strong>：进程所获得的资源在未使用完之前不能被其他进程强行夺走；&lt;/li>
&lt;li>&lt;strong>请求并保持条件&lt;/strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，但又对自己获得的资源不释放；&lt;/li>
&lt;li>&lt;strong>循环等待条件&lt;/strong>：存在一种进程资源的循环等待链，链中每个进程已获得的资源被链中另一个进程请求。即存在一个处于等待态的进程集合 {P1，P2，&amp;hellip;，Pn}，其中 Pi 等待的资源被 Pi+1 占用，Pn 等待的资源又被 P0 占用。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意&lt;/strong>：发生死锁时一定有循环等待，但是发生循环等待时不一定发生死锁！循环等待不一定发生死锁的原因时，同类资源数大于一。若系统中每类资源都只有一个资源，则会变成死锁。&lt;/p>
&lt;h2 id="二死锁的处理策略">二、死锁的处理策略
&lt;/h2>&lt;p>为使系统不发生死锁，必须设法破坏产生死锁的四个必要条件之一，或允许死锁发生，但当死锁发生时必须能检测并实现恢复。&lt;/p>
&lt;h3 id="1-死锁预防">1. 死锁预防
&lt;/h3>&lt;p>设置某些限制条件，破坏死锁的四个必要条件中的一个或多个，以防止死锁发生。&lt;/p>
&lt;h3 id="2-避免死锁">2. 避免死锁
&lt;/h3>&lt;p>在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。&lt;/p>
&lt;h3 id="3-死锁检测及解除">3. 死锁检测及解除
&lt;/h3>&lt;p>无需采取任何限制性措施，允许进程在允许过程中发生死锁。通过系统检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。&lt;/p>
&lt;h3 id="4-死锁处理策略的比较">4. 死锁处理策略的比较
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>措施&lt;/th>
&lt;th>资源分配策略&lt;/th>
&lt;th>各种可能模式&lt;/th>
&lt;th>主要优点&lt;/th>
&lt;th>主要缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>死锁预防&lt;/td>
&lt;td>保守，宁可资源闲置&lt;/td>
&lt;td>一次请求所有资源，资源剥夺，资源按序分配&lt;/td>
&lt;td>适用于突发式处理的进程，不必进行剥夺&lt;/td>
&lt;td>效率低，进程初始化时间延长；剥夺次数过多；不使灵活申请新资源&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>死锁避免&lt;/td>
&lt;td>使“预防”和“检测”的折中（在运行时判断是否可能死锁）&lt;/td>
&lt;td>寻找可能的安全允许顺序&lt;/td>
&lt;td>不必进行剥夺&lt;/td>
&lt;td>必须直到将来的资源请求；进程不能被长时间阻塞&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>死锁检测&lt;/td>
&lt;td>宽松，只要允许就分配资源&lt;/td>
&lt;td>定期检查死锁是否已经发生&lt;/td>
&lt;td>不延长进程初始化时间，允许对死锁进行现场化处理&lt;/td>
&lt;td>通过剥夺解除死锁，造成损失&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="三死锁预防">三、死锁预防
&lt;/h2>&lt;p>防止死锁的发生只需要破坏死锁产生四个必要条件之一即可。&lt;/p>
&lt;h3 id="1-破坏互斥条件">1. 破坏互斥条件
&lt;/h3>&lt;p>若系统资源都能共享使用，则系统不会进入死锁状态。但实际上的系统不可能所有资源共享，因此这种方法只能在特定的场合使用。&lt;/p>
&lt;h3 id="2-破坏不剥夺条件">2. 破坏不剥夺条件
&lt;/h3>&lt;p>当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。&lt;/p>
&lt;p>该策略实施起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会增加系统开销，降低系统吞吐量。这种方法常用于状态容易保存和恢复的资源，如 CPU。&lt;/p>
&lt;h3 id="3-破坏请求并保持条件">3. 破坏请求并保持条件
&lt;/h3>&lt;p>采用预先静态分配方法，即进程在允许前一次申请完它需要的全部资源，在它资源未满足前，不把它投入允许。一旦投入允许，这些资源就一直归它所有，不再提出其它资源请求，这就就不会发生死锁。&lt;/p>
&lt;p>这种方式实现简单，但是缺点也十分明显，系统资源被严重浪费，其中有些资源可能仅存在允许初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，由于个别资源长期被其它进程占用，将致使等待该资源的进程迟迟不能开始。&lt;/p>
&lt;h3 id="4-破坏循环等待条件">4. 破坏循环等待条件
&lt;/h3>&lt;p>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次性申请完。也就是说，只要进程提出申请分配资源 Ri，则该进程在以后的资源申请中就只能申请编号大于 Ri 的资源。&lt;/p>
&lt;p>这种方法的问题在于编号必须相对稳定，这就限制了新类型设备的增加；尽管在编号时已考虑到大多数作业使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，造成资源的浪费；此外，这种按规定申请资源的方法也必定会给用户编程造成麻烦。&lt;/p>
&lt;h2 id="四死锁避免">四、死锁避免
&lt;/h2>&lt;p>避免死锁同样属于事先预防策略，但并不事先采取某种限制措施破坏死锁的必要条件 ，而在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法能够获得较好的系统性能。&lt;/p>
&lt;h3 id="1-系统安全状态">1. 系统安全状态
&lt;/h3>&lt;p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算资源分配的安全性。若此次分配不会导致系统进入不安全的状态，则将系统资源分配给每个进程；否则进程等待。&lt;/p>
&lt;p>所谓安全状态，是指系统能按某种进程推进顺序为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时就称这个推进顺序为安全序列，若系统无法找到一个安全序列，则称这个系统处于不安全状态。&lt;/p>
&lt;p>假设系统中有三个进程 P1、P2和P3，共有12台磁带机。进程P1共需要10台磁带机，P2、P3分别需要4台和9台。假设在 T0 时刻，进程 P1、P2和P3已分别获得5台、2台和2台，还有3台未分配。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>进程&lt;/th>
&lt;th>最大需求&lt;/th>
&lt;th>已分配&lt;/th>
&lt;th>可用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>P1&lt;/td>
&lt;td>10&lt;/td>
&lt;td>5&lt;/td>
&lt;td>3&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>P2&lt;/td>
&lt;td>4&lt;/td>
&lt;td>2&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>P3&lt;/td>
&lt;td>9&lt;/td>
&lt;td>2&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>在 T0 时刻是安全的，因为存在一个安全序列 P2、P1、P3，即只要系统按此进程序列分配资源，那么每个进程都能顺利完成。若在 T0 时刻后，系统分配 1 台磁带机给 P3，则此时系统便进入不安全状态，因为此时已经无法再找到一个安全序列。&lt;/p>
&lt;p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。&lt;/p>
&lt;h3 id="2-银行家算法">2. 银行家算法
&lt;/h3>&lt;p>银行家算法是著名的死锁避免算法，其思想是：把操作系统当作银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。 操作系统按照银行家制定的规则为操作系统分配资源。当进程首次申请资源时，要测试该进程对资源的最大需求量，若系统现存的资源可以满足它的最大需求量，则按照当前的申请量分配资源，否则就推迟分配；当进程在执行中申请资源时，先测试该进程已占用的资源数与本次申请的资源数是否超过该进程对资源的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。&lt;/p>
&lt;h4 id="1数据结构描述">（1）数据结构描述
&lt;/h4>&lt;p>可利用资源向量 Available：含有 m 个元素的数组，其中每个元素代表一类可用资源的数目。 Available[j] = K 表示系统中 现有 Rj 类资源 K 个。&lt;/p>
&lt;p>最大需求矩阵 Max：n * m 矩阵，定义系统中 n 个进程中的每个进程对 m 类资源的最大需求。简单来说，一行代表一个进程，一列代表一类资源。Max[i, j] = K 表示该进程需要 Rj 类资源的最大数目为 K。&lt;/p>
&lt;p>分配矩阵 Allocation：n * m 矩阵，定义系统中每类资源当前已分配给每个进程的资源数。Allocation][i, j] = K 表示进程 i 当前已分得 Rj 类的资源数目为 K。&lt;/p>
&lt;p>需求矩阵 Need：n * m 矩阵，表示每个进程尚需的各类资源数。Need[i, j] = K 表示进程 i 还需要 Rj 类资源的数目为 K。&lt;/p>
$$
Need = Max - Allocation
$$&lt;h4 id="2银行家算法描述">（2）银行家算法描述
&lt;/h4>&lt;p>设 Request 是进程 Pi 的请求向量，Request_i[j] = K 表示进程 Pi 需要 j 类资源 K 个，当 Pi 发出资源请求后，系统按下述步骤进行检查：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>若 Request_i[j] &amp;lt;= Need[i, j]，则转向步骤 2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若 Request_i[j] &amp;lt;= Available[j]，则转向步骤 3；否则，表示尚无足够资源，Pi 须等待；&lt;/p>
&lt;/li>
&lt;li>
$$
Available = Available - Request\\
Allocation[i, j] = Allocation[i, j] + Request_i[j]\\
Need[i, j]= Need[i, j] - Request_i[j]
$$&lt;/li>
&lt;li>
&lt;p>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态， 让进程等待。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="3安全性算法">（3）安全性算法
&lt;/h4>&lt;ol>
&lt;li>初始时安全序列为空。&lt;/li>
&lt;li>从 Need 矩阵中找出符合条件的行；改行对应的进程不在安全序列中，而且该行小于等于 Available 向量，找到后，把对应的进程加入安全序列；若找不到，则执行步骤 4；&lt;/li>
&lt;li>进程 Pi 进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源，故而执行 &lt;code>Available = Available + Allocation[i]&lt;/code>，其中 Allocation[i] 表示进程 Pi 代表的在 Allocation 矩阵中对应的行，返回步骤 2；&lt;/li>
&lt;li>若此时安全序列中已有所有进程，则系统处于安全状态，否则系统处于不安全状态。&lt;/li>
&lt;/ol>
&lt;h3 id="3-安全性算法举例">3. 安全性算法举例
&lt;/h3>&lt;p>假定系统中有 5 个进程&lt;code>{P0, P1, P2, P3, P4}&lt;/code>和 3 类资源&lt;code>A B C&lt;/code>，各种资源的数量分别为10、5、7，在 T0 时刻的资源分配情况见下表：&lt;/p>
&lt;style type="text/css">
.tg {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-ao2g{border-color:#333333;text-align:center;vertical-align:top}
&lt;/style>
&lt;table class="tg">
&lt;thead>
&lt;tr>
&lt;th class="tg-ao2g">进程 \ 资源情况&lt;/th>
&lt;th class="tg-ao2g">Max &lt;br>A B C&lt;/th>
&lt;th class="tg-ao2g">Allocation&lt;br>A B C&lt;/th>
&lt;th class="tg-ao2g">Available&lt;br>A B C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td class="tg-ao2g">P0&lt;/td>
&lt;td class="tg-ao2g">7 5 3&lt;/td>
&lt;td class="tg-ao2g">0 1 0&lt;/td>
&lt;td class="tg-ao2g" rowspan="5">3 3 2&lt;br>(2 3 6)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td class="tg-ao2g">P1&lt;/td>
&lt;td class="tg-ao2g">3 2 2&lt;/td>
&lt;td class="tg-ao2g">2 0 0&lt;br>(3 0 2)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td class="tg-ao2g">P2&lt;/td>
&lt;td class="tg-ao2g">9 0 2&lt;/td>
&lt;td class="tg-ao2g">3 0 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td class="tg-ao2g">P3&lt;/td>
&lt;td class="tg-ao2g">2 2 2&lt;/td>
&lt;td class="tg-ao2g">2 1 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td class="tg-ao2g">P4&lt;/td>
&lt;td class="tg-ao2g">4 3 3&lt;/td>
&lt;td class="tg-ao2g">0 0 2&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>
$$
\begin{bmatrix}
7 &amp; 5 &amp; 3 \\
3 &amp; 2 &amp; 2 \\
9 &amp; 0 &amp; 2 \\
2 &amp; 2 &amp; 2 \\
4 &amp; 3 &amp; 3 \\
\end{bmatrix} - \begin{bmatrix}
0 &amp; 1 &amp; 0 \\
2 &amp; 0 &amp; 0 \\
3 &amp; 0 &amp; 2 \\
2 &amp; 1 &amp; 1 \\
0 &amp; 0 &amp; 2 \\
\end{bmatrix} =
\begin{bmatrix}
7 &amp; 4 &amp; 3 \\
1 &amp; 2 &amp; 2 \\
6 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 \\
4 &amp; 3 &amp; 1 \\
\end{bmatrix} \\
Max \qquad\quad Allocation \qquad\quad Need
$$&lt;/li>
&lt;li>
&lt;p>然后，将 Available 向量与 Need 矩阵的各行进行比较，找出比 Available 矩阵小的行；&lt;/p>
&lt;/li>
&lt;li>
$$
(3 \ 3 \ 2) \ + \ (2 \ 0 \ 0) \ = \ (5 \ 3 \ 2) = Available \\
{\begin{bmatrix}
7 &amp; 4 &amp; 3 \\
6 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 1 \\
4 &amp; 3 &amp; 1 \\
\end{bmatrix}}
$$&lt;/li>
&lt;/ol>
&lt;p>去掉了对应的一行，再用更新后的 Available 向量和 Need 矩阵重复步骤 2，最后得到一个安全序列 &lt;code>{P1, P3, P4, P2, P0}&lt;/code>。&lt;/p>
&lt;h2 id="五死锁检测和解除">五、死锁检测和解除
&lt;/h2>&lt;p>若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。&lt;/p>
&lt;h3 id="1-资源分配图">1. 资源分配图
&lt;/h3>&lt;p>系统死锁可利用资源分配图来描述：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-214549.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;p>圆圈代表一个进程，框代表一类资源。由于一种类型的资源可能有多个，因此用框中的一个圆代表一类资源中的一个资源。从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源；从资源到进程的边称为分配边，表示该资源已有一个资源分配给了该进程。&lt;/p>
&lt;h3 id="2-死锁定理">2. 死锁定理
&lt;/h3>&lt;p>可以通过将资源分配图简化的方法来检测系统状态S是否为死锁状态。简化方法如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在资源分配图中，找出既不阻塞又不是孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。若所有的连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图 a中，P1是满足这一条件的进程结点，将 P1 的所有边消去，便得到图 b 所示的情况。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在上图中，进程P2 就满足这样的条件。根据第 1 条中的方法进行一系列简化后,若能消去图中所有的边，则称该图是可完全简化的，如图所示。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-214603.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;p>S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的,该条件为死锁定理。&lt;/p>
&lt;h3 id="3-死锁解除">3. 死锁解除
&lt;/h3>&lt;p>一旦检查出死锁，就应当立即采取相应的措施来解除死锁。死锁解除的主要方法有：&lt;/p>
&lt;ul>
&lt;li>资源剥夺法：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其它死锁进程。但应当防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。&lt;/li>
&lt;li>撤销进程法：强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行；&lt;/li>
&lt;li>进程回退法：让一个或多个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺，要求系统保持进程的历史信息，设置还原点。&lt;/li>
&lt;/ul></description></item><item><title>3.1 内存管理概念</title><link>https://wlynxg.github.io/blog/p/3.1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</link><pubDate>Fri, 22 Aug 2025 17:34:52 +0800</pubDate><guid>https://wlynxg.github.io/blog/p/3.1-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%A6%82%E5%BF%B5/</guid><description>&lt;h1 id="31-内存管理概念">3.1 内存管理概念
&lt;/h1>&lt;h2 id="一内存管理的基本原理和要求">一、内存管理的基本原理和要求
&lt;/h2>&lt;p>内存管理（Memory Management）是操作系统中最重要和最复杂的内容之一。有效的内存管理在多道程序设计中非常重要，它不仅可以方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。&lt;/p>
&lt;p>内存管理的功能有：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>内存空间分配与回收&lt;/strong>：由操作系统完成主存储器空间的分配和管理，使程序员摆脱内存分配的麻烦，提高编程效率；&lt;/li>
&lt;li>&lt;strong>地址转换&lt;/strong>：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理器必须提供地址变换功能，把逻辑地址转换成相应的物理地址；&lt;/li>
&lt;li>&lt;strong>内存空间扩充&lt;/strong>：利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存；&lt;/li>
&lt;li>&lt;strong>存储保护&lt;/strong>：保证各道作业在各自的存储空间内运行，互不干扰。&lt;/li>
&lt;/ul>
&lt;h3 id="1-程序装入和链接">1. 程序装入和链接
&lt;/h3>&lt;p>创建进程首先要将程序和数据接入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>编译&lt;/strong>：由编译程序将用户源代码编译成若干目标模块；&lt;/li>
&lt;li>&lt;strong>链接&lt;/strong>：由链接程序将编译后形成的一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块；&lt;/li>
&lt;li>&lt;strong>装入&lt;/strong>：由装入程序将装入模块装入内存运行。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140350.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;p>程序的链接有以下三种方式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>静态链接&lt;/strong>：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的执行程序，以后不再拆开；&lt;/li>
&lt;li>&lt;strong>装入时动态链接&lt;/strong>：将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式；&lt;/li>
&lt;li>&lt;strong>运行时动态链接&lt;/strong>：对某些目标模块的链接，是在程序中需要该目标模块时才进行的，其优点是便于修改和更新，便于实现对目标模块的共享。&lt;/li>
&lt;/ul>
&lt;p>内存装入模块在装入内存时，同样有三种方式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>绝对装入&lt;/strong>：在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，故故不需要对程序和数据的地址进行修改；绝对装入方式只适合单道程序环境。另外程序中所用的绝对地址，可在编译或汇编时给出，也可以由程序员直接赋予。通常情况下在程序中采用的是符号地址，编译或汇编时再转换为绝对地址；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可重定位装入&lt;/strong>：在多道程序环境下，多个目标模块的起始地址（简称始址）通常都从 0 开始，程序中的其他地址都是相对于始址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。装入时对目标程序中指令和数据的修改过程称为&lt;strong>重定位&lt;/strong>。&lt;/p>
&lt;ul>
&lt;li>静态重定位的特点是：一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则不能装入作业。一旦进入内存，整个运行期间就不能在内存中移动，也不能再申请空间；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>动态运行时装入（动态重定位）&lt;/strong>：程序在内存中若发生移动，则需要采用动态的装入方式。装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正需要执行的时候才执行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。&lt;/p>
&lt;ul>
&lt;li>动态重定位的特点是：可以将程序分配到不连续的存储区中中；在程序运行之前可以只装入它的部分代码即可投入运行，然后再程序运行期间，根据需要动态申请分配内存；便于程序段的共享，可以向用户提供一个比存储空间大得多的地址空间。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140403.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h3 id="2-逻辑地址空间于物理地址空间">2. 逻辑地址空间于物理地址空间
&lt;/h3>&lt;p>编译后，每个目标模块都从 0 号单元开始编址，这称为该目标模块的&lt;strong>相对地址（逻辑地址）&lt;/strong>。当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按照各个模块的相对地址构成统一的从 0 号单元开始编址的&lt;strong>逻辑地址空间&lt;/strong>。用户程序和程序员只需要知道逻辑地址，而内存管理的具体机制则是完全透明的，只有系统编程人员才会涉及。不同进程可以拥有相同的逻辑地址，因为这些逻辑地址可以映射到主存的不同位置。&lt;/p>
&lt;p>&lt;strong>物理地址空间&lt;/strong>是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程就称为&lt;strong>地址重定位&lt;/strong>。&lt;/p>
&lt;h3 id="3-内存保护">3. 内存保护
&lt;/h3>&lt;p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。&lt;/p>
&lt;p>内存保护可采取两种方法：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在 CPU 中设置一对一上、下限寄存器；存放用户作业在主存中的下限和上限地址，每当 CPU 要访问一个地址时，分别和两个寄存器的值相比较，判断有无越界；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>采用**重定位寄存器（基址寄存器）&lt;strong>和&lt;/strong>界地址寄存器（限长寄存器）**来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.githubusercontent.com/wlynxg/pic/main/2025/06/01/20250601-140418.png"
loading="lazy"
alt="image.png"
>&lt;/p>
&lt;h2 id="二覆盖与交换">二、覆盖与交换
&lt;/h2>&lt;p>覆盖和交换技术是在多道程序环境下来扩充内存的两种方法。&lt;/p>
&lt;h3 id="1-覆盖">1. 覆盖
&lt;/h3>&lt;p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。&lt;/p>
&lt;p>覆盖的基本思想如下：由于程序运行时并非任何时候都要访问程序及数据的各个部分，因此可以把用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。&lt;/p>
&lt;p>覆盖技术的特点是：打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍然不能运行。此外，内存中能够更新的地方只有覆盖区的段，不在覆盖区时会常驻内存中。&lt;/p>
&lt;h3 id="2-交换">2. 交换
&lt;/h3>&lt;p>交换的基本思想是：&lt;strong>把处于等待状态的程序从内存中移到辅存中，把内存空间腾出来，这一过程又称换出。&lt;/strong>&lt;/p>
&lt;p>有关交换，需要注意以下几个问题：&lt;/p>
&lt;ul>
&lt;li>交换需要备份存储，通常是快速磁盘。它必须足够大，并能够提供对这些内存映像的直接访问；&lt;/li>
&lt;li>为了有效使用 CPU，需要使每个进程的执行时间比交换时间长，而影响交换时间的主要是转移时间。转移时间与所交换的内存空间成正比；&lt;/li>
&lt;li>交换时间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快；&lt;/li>
&lt;li>交换通常再又许多进程运行且内存空间吃紧时开始启动，而系统负荷降低就暂停；&lt;/li>
&lt;li>普通的交换使用不多，但交换策略的某些变体在许多系统（如UNIX系统）中仍然发挥作用。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>交换技术主要在不同进程之间进行，而覆盖主要在同一个程序或进程中&lt;/strong>。现代操作系统中，虚拟内存技术已经替代了覆盖技术；而交换技术仍然具有较强的生命力。&lt;/p>
&lt;h2 id="三连续分配管理方式">三、连续分配管理方式
&lt;/h2>&lt;p>连续分配管理方式是指为一个用户程序分配一个连续的内存空间。连续分配方式主要包括单一连续分配、固定分区和动态分区分配。&lt;/p>
&lt;h3 id="1-单一连续分配">1. 单一连续分配
&lt;/h3>&lt;p>内存在此方式下分为系统区和用户区。系统区仅供操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。因为内存在永远只有一道程序，因此肯定不会因为访问越界而干扰其他程序。&lt;/p>
&lt;p>这种方式的优点是简单、无外部碎片，可以采用覆盖技术，不需要额外的技术支持。缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。&lt;/p>
&lt;h3 id="2-固定分区分配">2. 固定分区分配
&lt;/h3></description></item></channel></rss>